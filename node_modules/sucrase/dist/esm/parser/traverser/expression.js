/* eslint max-len: 0 */

// A recursive descent parser operates by defining functions for all
// syntactic elements, and recursively calling those, each function
// advancing the input stream and returning an AST node. Precedence
// of constructs (for example, the fact that `!x[1]` means `!(x[1])`
// instead of `(!x)[1]` is handled by the fact that the parser
// function that parses unary prefix operators is called first, and
// in turn calls the function that parses `[]` subscripts â€” that
// way, it'll receive the node for `x[1]` already parsed, and wraps
// *that* in the unary operator node.
//
// Acorn uses an [operator precedence parser][opp] to handle binary
// operator precedence, because it is much more compact than using
// the technique outlined above, which uses different, nesting
// functions to specify precedence, for all of the ten binary
// precedence levels that JavaScript defines.
//
// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser

import {
  flowParseArrow,
  flowParseFunctionBodyAndFinish,
  flowParseMaybeAssign,
  flowParseSubscript,
  flowParseSubscripts,
  flowParseVariance,
  flowStartParseAsyncArrowFromCallExpression,
  flowStartParseNewArguments,
  flowStartParseObjPropValue,
} from "../plugins/flow";
import {jsxParseElement} from "../plugins/jsx/index";
import {typedParseConditional, typedParseParenItem} from "../plugins/types";
import {
  tsParseArrow,
  tsParseFunctionBodyAndFinish,
  tsParseMaybeAssign,
  tsParseSubscript,
  tsParseType,
  tsParseTypeAssertion,
  tsStartParseAsyncArrowFromCallExpression,
  tsStartParseObjPropValue,
} from "../plugins/typescript";
import {
  eat,
  IdentifierRole,
  lookaheadCharCode,
  lookaheadType,
  match,
  next,
  nextTemplateToken,
  popTypeContext,
  pushTypeContext,
  rescan_gt,
  retokenizeSlashAsRegex,
} from "../tokenizer/index";
import {ContextualKeyword} from "../tokenizer/keywords";
import {Scope} from "../tokenizer/state";
import {TokenType, TokenType as tt} from "../tokenizer/types";
import {charCodes} from "../util/charcodes";
import {IS_IDENTIFIER_START} from "../util/identifier";
import {getNextContextId, isFlowEnabled, isJSXEnabled, isTypeScriptEnabled, state} from "./base";
import {
  markPriorBindingIdentifier,
  parseBindingIdentifier,
  parseMaybeDefault,
  parseRest,
  parseSpread,
} from "./lval";
import {
  parseBlock,
  parseBlockBody,
  parseClass,
  parseDecorators,
  parseFunction,
  parseFunctionParams,
} from "./statement";
import {
  canInsertSemicolon,
  eatContextual,
  expect,
  expectContextual,
  hasFollowingLineBreak,
  hasPrecedingLineBreak,
  isContextual,
  unexpected,
} from "./util";

export class StopState {
  
  constructor(stop) {
    this.stop = stop;
  }
}

// ### Expression parsing

// These nest, from the most general expression type at the top to
// 'atomic', nondivisible expression types at the bottom. Most of
// the functions will simply let the function (s) below them parse,
// and, *if* the syntactic construct they handle is present, wrap
// the AST node that the inner parser gave them in another node.
export function parseExpression(noIn = false) {
  parseMaybeAssign(noIn);
  if (match(tt.comma)) {
    while (eat(tt.comma)) {
      parseMaybeAssign(noIn);
    }
  }
}

/**
 * noIn is used when parsing a for loop so that we don't interpret a following "in" as the binary
 * operatior.
 * isWithinParens is used to indicate that we're parsing something that might be a comma expression
 * or might be an arrow function or might be a Flow type assertion (which requires explicit parens).
 * In these cases, we should allow : and ?: after the initial "left" part.
 */
export function parseMaybeAssign(noIn = false, isWithinParens = false) {
  if (isTypeScriptEnabled) {
    return tsParseMaybeAssign(noIn, isWithinParens);
  } else if (isFlowEnabled) {
    return flowParseMaybeAssign(noIn, isWithinParens);
  } else {
    return baseParseMaybeAssign(noIn, isWithinParens);
  }
}

// Parse an assignment expression. This includes applications of
// operators like `+=`.
// Returns true if the expression was an arrow function.
export function baseParseMaybeAssign(noIn, isWithinParens) {
  if (match(tt._yield)) {
    parseYield();
    return false;
  }

  if (match(tt.parenL) || match(tt.name) || match(tt._yield)) {
    state.potentialArrowAt = state.start;
  }

  const wasArrow = parseMaybeConditional(noIn);
  if (isWithinParens) {
    parseParenItem();
  }
  if (state.type & TokenType.IS_ASSIGN) {
    next();
    parseMaybeAssign(noIn);
    return false;
  }
  return wasArrow;
}

// Parse a ternary conditional (`?:`) operator.
// Returns true if the expression was an arrow function.
function parseMaybeConditional(noIn) {
  const wasArrow = parseExprOps(noIn);
  if (wasArrow) {
    return true;
  }
  parseConditional(noIn);
  return false;
}

function parseConditional(noIn) {
  if (isTypeScriptEnabled || isFlowEnabled) {
    typedParseConditional(noIn);
  } else {
    baseParseConditional(noIn);
  }
}

export function baseParseConditional(noIn) {
  if (eat(tt.question)) {
    parseMaybeAssign();
    expect(tt.colon);
    parseMaybeAssign(noIn);
  }
}

// Start the precedence parser.
// Returns true if this was an arrow function
function parseExprOps(noIn) {
  const startTokenIndex = state.tokens.length;
  const wasArrow = parseMaybeUnary();
  if (wasArrow) {
    return true;
  }
  parseExprOp(startTokenIndex, -1, noIn);
  return false;
}

// Parse binary operators with the operator precedence parsing
// algorithm. `left` is the left-hand side of the operator.
// `minPrec` provides context that allows the function to stop and
// defer further parser to one of its callers when it encounters an
// operator that has a lower precedence than the set it is parsing.
function parseExprOp(startTokenIndex, minPrec, noIn) {
  if (
    isTypeScriptEnabled &&
    (tt._in & TokenType.PRECEDENCE_MASK) > minPrec &&
    !hasPrecedingLineBreak() &&
    (eatContextual(ContextualKeyword._as) || eatContextual(ContextualKeyword._satisfies))
  ) {
    const oldIsType = pushTypeContext(1);
    tsParseType();
    popTypeContext(oldIsType);
    rescan_gt();
    parseExprOp(startTokenIndex, minPrec, noIn);
    return;
  }

  const prec = state.type & TokenType.PRECEDENCE_MASK;
  if (prec > 0 && (!noIn || !match(tt._in))) {
    if (prec > minPrec) {
      const op = state.type;
      next();
      if (op === tt.nullishCoalescing) {
        state.tokens[state.tokens.length - 1].nullishStartIndex = startTokenIndex;
      }

      const rhsStartTokenIndex = state.tokens.length;
      parseMaybeUnary();
      // Extend the right operand of this operator if possible.
      parseExprOp(rhsStartTokenIndex, op & TokenType.IS_RIGHT_ASSOCIATIVE ? prec - 1 : prec, noIn);
      if (op === tt.nullishCoalescing) {
        state.tokens[startTokenIndex].numNullishCoalesceStarts++;
        state.tokens[state.tokens.length - 1].numNullishCoalesceEnds++;
      }
      // Continue with any future operator holding this expression as the left operand.
      parseExprOp(startTokenIndex, minPrec, noIn);
    }
  }
}

// Parse unary operators, both prefix and postfix.
// Returns true if this was an arrow function.
export function parseMaybeUnary() {
  if (isTypeScriptEnabled && !isJSXEnabled && eat(tt.lessThan)) {
    tsParseTypeAssertion();
    return false;
  }
  if (
    isContextual(ContextualKeyword._module) &&
    lookaheadCharCode() === charCodes.leftCurlyBrace &&
    !hasFollowingLineBreak()
  ) {
    parseModuleExpression();
    return false;
  }
  if (state.type & TokenType.IS_PREFIX) {
    next();
    parseMaybeUnary();
    return false;
  }

  const wasArrow = parseExprSubscripts();
  if (wasArrow) {
    return true;
  }
  while (state.type & TokenType.IS_POSTFIX && !canInsertSemicolon()) {
    // The tokenizer calls everything a preincrement, so make it a postincrement when
    // we see it in that context.
    if (state.type === tt.preIncDec) {
      state.type = tt.postIncDec;
    }
    next();
  }
  return false;
}

// Parse call, dot, and `[]`-subscript expressions.
// Returns true if this was an arrow function.
export function parseExprSubscripts() {
  const startTokenIndex = state.tokens.length;
  const wasArrow = parseExprAtom();
  if (wasArrow) {
    return true;
  }
  parseSubscripts(startTokenIndex);
  // If there was any optional chain operation, the start token would be marked
  // as such, so also mark the end now.
  if (state.tokens.length > startTokenIndex && state.tokens[startTokenIndex].isOptionalChainStart) {
    state.tokens[state.tokens.length - 1].isOptionalChainEnd = true;
  }
  return false;
}

function parseSubscripts(startTokenIndex, noCalls = false) {
  if (isFlowEnabled) {
    flowParseSubscripts(startTokenIndex, noCalls);
  } else {
    baseParseSubscripts(startTokenIndex, noCalls);
  }
}

export function baseParseSubscripts(startTokenIndex, noCalls = false) {
  const stopState = new StopState(false);
  do {
    parseSubscript(startTokenIndex, noCalls, stopState);
  } while (!stopState.stop && !state.error);
}

function parseSubscript(startTokenIndex, noCalls, stopState) {
  if (isTypeScriptEnabled) {
    tsParseSubscript(startTokenIndex, noCalls, stopState);
  } else if (isFlowEnabled) {
    flowParseSubscript(startTokenIndex, noCalls, stopState);
  } else {
    baseParseSubscript(startTokenIndex, noCalls, stopState);
  }
}

/** Set 'state.stop = true' to indicate that we should stop parsing subscripts. */
export function baseParseSubscript(
  startTokenIndex,
  noCalls,
  stopState,
) {
  if (!noCalls && eat(tt.doubleColon)) {
    parseNoCallExpr();
    stopState.stop = true;
    // Propagate startTokenIndex so that `a::b?.()` will keep `a` as the first token. We may want
    // to revisit this in the future when fully supporting bind syntax.
    parseSubscripts(startTokenIndex, noCalls);
  } else if (match(tt.questionDot)) {
    state.tokens[startTokenIndex].isOptionalChainStart = true;
    if (noCalls && lookaheadType() === tt.parenL) {
      stopState.stop = true;
      return;
    }
    next();
    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;

    if (eat(tt.bracketL)) {
      parseExpression();
      expect(tt.bracketR);
    } else if (eat(tt.parenL)) {
      parseCallExpressionArguments();
    } else {
      parseMaybePrivateName();
    }
  } else if (eat(tt.dot)) {
    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    parseMaybePrivateName();
  } else if (eat(tt.bracketL)) {
    state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
    parseExpression();
    expect(tt.bracketR);
  } else if (!noCalls && match(tt.parenL)) {
    if (atPossibleAsync()) {
      // We see "async", but it's possible it's a usage of the name "async". Parse as if it's a
      // function call, and if we see an arrow later, backtrack and re-parse as a parameter list.
      const snapshot = state.snapshot();
      const asyncStartTokenIndex = state.tokens.length;
      next();
      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;

      const callContextId = getNextContextId();

      state.tokens[state.tokens.length - 1].contextId = callContextId;
      parseCallExpressionArguments();
      state.tokens[state.tokens.length - 1].contextId = callContextId;

      if (shouldParseAsyncArrow()) {
        // We hit an arrow, so backtrack and start again parsing function parameters.
        state.restoreFromSnapshot(snapshot);
        stopState.stop = true;
        state.scopeDepth++;

        parseFunctionParams();
        parseAsyncArrowFromCallExpression(asyncStartTokenIndex);
      }
    } else {
      next();
      state.tokens[state.tokens.length - 1].subscriptStartIndex = startTokenIndex;
      const callContextId = getNextContextId();
      state.tokens[state.tokens.length - 1].contextId = callContextId;
      parseCallExpressionArguments();
      state.tokens[state.tokens.length - 1].contextId = callContextId;
    }
  } else if (match(tt.backQuote)) {
    // Tagged template expression.
    parseTemplate();
  } else {
    stopState.stop = true;
  }
}

export function atPossibleAsync() {
  // This was made less strict than the original version to avoid passing around nodes, but it
  // should be safe to have rare false positives here.
  return (
    state.tokens[state.tokens.length - 1].contextualKeyword === ContextualKeyword._async &&
    !canInsertSemicolon()
  );
}

export function parseCallExpressionArguments() {
  let first = true;
  while (!eat(tt.parenR) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(tt.comma);
      if (eat(tt.parenR)) {
        break;
      }
    }

    parseExprListItem(false);
  }
}

function shouldParseAsyncArrow() {
  return match(tt.colon) || match(tt.arrow);
}

function parseAsyncArrowFromCallExpression(startTokenIndex) {
  if (isTypeScriptEnabled) {
    tsStartParseAsyncArrowFromCallExpression();
  } else if (isFlowEnabled) {
    flowStartParseAsyncArrowFromCallExpression();
  }
  expect(tt.arrow);
  parseArrowExpression(startTokenIndex);
}

// Parse a no-call expression (like argument of `new` or `::` operators).

function parseNoCallExpr() {
  const startTokenIndex = state.tokens.length;
  parseExprAtom();
  parseSubscripts(startTokenIndex, true);
}

// Parse an atomic expression â€” either a single token that is an
// expression, an expression started by a keyword like `function` or
// `new`, or an expression wrapped in punctuation like `()`, `[]`,
// or `{}`.
// Returns true if the parsed expression was an arrow function.
export function parseExprAtom() {
  if (eat(tt.modulo)) {
    // V8 intrinsic expression. Just parse the identifier, and the function invocation is parsed
    // naturally.
    parseIdentifier();
    return false;
  }

  if (match(tt.jsxText) || match(tt.jsxEmptyText)) {
    parseLiteral();
    return false;
  } else if (match(tt.lessThan) && isJSXEnabled) {
    state.type = tt.jsxTagStart;
    jsxParseElement();
    next();
    return false;
  }

  const canBeArrow = state.potentialArrowAt === state.start;
  switch (state.type) {
    case tt.slash:
    case tt.assign:
      retokenizeSlashAsRegex();
    // Fall through.

    case tt._super:
    case tt._this:
    case tt.regexp:
    case tt.num:
    case tt.bigint:
    case tt.decimal:
    case tt.string:
    case tt._null:
    case tt._true:
    case tt._false:
      next();
      return false;

    case tt._import:
      next();
      if (match(tt.dot)) {
        // import.meta
        state.tokens[state.tokens.length - 1].type = tt.name;
        next();
        parseIdentifier();
      }
      return false;

    case tt.name: {
      const startTokenIndex = state.tokens.length;
      const functionStart = state.start;
      const contextualKeyword = state.contextualKeyword;
      parseIdentifier();
      if (contextualKeyword === ContextualKeyword._await) {
        parseAwait();
        return false;
      } else if (
        contextualKeyword === ContextualKeyword._async &&
        match(tt._function) &&
        !canInsertSemicolon()
      ) {
        next();
        parseFunction(functionStart, false);
        return false;
      } else if (
        canBeArrow &&
        contextualKeyword === ContextualKeyword._async &&
        !canInsertSemicolon() &&
        match(tt.name)
      ) {
        state.scopeDepth++;
        parseBindingIdentifier(false);
        expect(tt.arrow);
        // let foo = async bar => {};
        parseArrowExpression(startTokenIndex);
        return true;
      } else if (match(tt._do) && !canInsertSemicolon()) {
        next();
        parseBlock();
        return false;
      }

      if (canBeArrow && !canInsertSemicolon() && match(tt.arrow)) {
        state.scopeDepth++;
        markPriorBindingIdentifier(false);
        expect(tt.arrow);
        parseArrowExpression(startTokenIndex);
        return true;
      }

      state.tokens[state.tokens.length - 1].identifierRole = IdentifierRole.Access;
      return false;
    }

    case tt._do: {
      next();
      parseBlock();
      return false;
    }

    case tt.parenL: {
      const wasArrow = parseParenAndDistinguishExpression(canBeArrow);
      return wasArrow;
    }

    case tt.bracketL:
      next();
      parseExprList(tt.bracketR, true);
      return false;

    case tt.braceL:
      parseObj(false, false);
      return false;

    case tt._function:
      parseFunctionExpression();
      return false;

    case tt.at:
      parseDecorators();
    // Fall through.

    case tt._class:
      parseClass(false);
      return false;

    case tt._new:
      parseNew();
      return false;

    case tt.backQuote:
      parseTemplate();
      return false;

    case tt.doubleColon: {
      next();
      parseNoCallExpr();
      return false;
    }

    case tt.hash: {
      const code = lookaheadCharCode();
      if (IS_IDENTIFIER_START[code] || code === charCodes.backslash) {
        parseMaybePrivateName();
      } else {
        next();
      }
      // Smart pipeline topic reference.
      return false;
    }

    default:
      unexpected();
      return false;
  }
}

function parseMaybePrivateName() {
  eat(tt.hash);
  parseIdentifier();
}

function parseFunctionExpression() {
  const functionStart = state.start;
  parseIdentifier();
  if (eat(tt.dot)) {
    // function.sent
    parseIdentifier();
  }
  parseFunction(functionStart, false);
}

export function parseLiteral() {
  next();
}

export function parseParenExpression() {
  expect(tt.parenL);
  parseExpression();
  expect(tt.parenR);
}

// Returns true if this was an arrow expression.
function parseParenAndDistinguishExpression(canBeArrow) {
  // Assume this is a normal parenthesized expression, but if we see an arrow, we'll bail and
  // start over as a parameter list.
  const snapshot = state.snapshot();

  const startTokenIndex = state.tokens.length;
  expect(tt.parenL);

  let first = true;

  while (!match(tt.parenR) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(tt.comma);
      if (match(tt.parenR)) {
        break;
      }
    }

    if (match(tt.ellipsis)) {
      parseRest(false /* isBlockScope */);
      parseParenItem();
      break;
    } else {
      parseMaybeAssign(false, true);
    }
  }

  expect(tt.parenR);

  if (canBeArrow && shouldParseArrow()) {
    const wasArrow = parseArrow();
    if (wasArrow) {
      // It was an arrow function this whole time, so start over and parse it as params so that we
      // get proper token annotations.
      state.restoreFromSnapshot(snapshot);
      state.scopeDepth++;
      // Don't specify a context ID because arrow functions don't need a context ID.
      parseFunctionParams();
      parseArrow();
      parseArrowExpression(startTokenIndex);
      if (state.error) {
        // Nevermind! This must have been something that looks very much like an
        // arrow function but where its "parameter list" isn't actually a valid
        // parameter list. Force non-arrow parsing.
        // See https://github.com/alangpierce/sucrase/issues/666 for an example.
        state.restoreFromSnapshot(snapshot);
        parseParenAndDistinguishExpression(false);
        return false;
      }
      return true;
    }
  }

  return false;
}

function shouldParseArrow() {
  return match(tt.colon) || !canInsertSemicolon();
}

// Returns whether there was an arrow token.
export function parseArrow() {
  if (isTypeScriptEnabled) {
    return tsParseArrow();
  } else if (isFlowEnabled) {
    return flowParseArrow();
  } else {
    return eat(tt.arrow);
  }
}

function parseParenItem() {
  if (isTypeScriptEnabled || isFlowEnabled) {
    typedParseParenItem();
  }
}

// New's precedence is slightly tricky. It must allow its argument to
// be a `[]` or dot subscript expression, but not a call â€” at least,
// not without wrapping it in parentheses. Thus, it uses the noCalls
// argument to parseSubscripts to prevent it from consuming the
// argument list.
function parseNew() {
  expect(tt._new);
  if (eat(tt.dot)) {
    // new.target
    parseIdentifier();
    return;
  }
  parseNewCallee();
  if (isFlowEnabled) {
    flowStartParseNewArguments();
  }
  if (eat(tt.parenL)) {
    parseExprList(tt.parenR);
  }
}

function parseNewCallee() {
  parseNoCallExpr();
  eat(tt.questionDot);
}

export function parseTemplate() {
  // Finish `, read quasi
  nextTemplateToken();
  // Finish quasi, read ${
  nextTemplateToken();
  while (!match(tt.backQuote) && !state.error) {
    expect(tt.dollarBraceL);
    parseExpression();
    // Finish }, read quasi
    nextTemplateToken();
    // Finish quasi, read either ${ or `
    nextTemplateToken();
  }
  next();
}

// Parse an object literal or binding pattern.
export function parseObj(isPattern, isBlockScope) {
  // Attach a context ID to the object open and close brace and each object key.
  const contextId = getNextContextId();
  let first = true;

  next();
  state.tokens[state.tokens.length - 1].contextId = contextId;

  while (!eat(tt.braceR) && !state.error) {
    if (first) {
      first = false;
    } else {
      expect(tt.comma);
      if (eat(tt.braceR)) {
        break;
      }
    }

    let isGenerator = false;
    if (match(tt.ellipsis)) {
      const previousIndex = state.tokens.length;
      parseSpread();
      if (isPattern) {
        // Mark role when the only thing being spread over is an identifier.
        if (state.tokens.length === previousIndex + 2) {
          markPriorBindingIdentifier(isBlockScope);
        }
        if (eat(tt.braceR)) {
          break;
        }
      }
      continue;
    }

    if (!isPattern) {
      isGenerator = eat(tt.star);
    }

    if (!isPattern && isContextual(ContextualKeyword._async)) {
      if (isGenerator) unexpected();

      parseIdentifier();
      if (
        match(tt.colon) ||
        match(tt.parenL) ||
        match(tt.braceR) ||
        match(tt.eq) ||
        match(tt.comma)
      ) {
        // This is a key called "async" rather than an async function.
      } else {
        if (match(tt.star)) {
          next();
          isGenerator = true;
        }
        parsePropertyName(contextId);
      }
    } else {
      parsePropertyName(contextId);
    }

    parseObjPropValue(isPattern, isBlockScope, contextId);
  }

  state.tokens[state.tokens.length - 1].contextId = contextId;
}

function isGetterOrSetterMethod(isPattern) {
  // We go off of the next and don't bother checking if the node key is actually "get" or "set".
  // This lets us avoid generating a node, and should only make the validation worse.
  return (
    !isPattern &&
    (match(tt.string) || // get "string"() {}
      match(tt.num) || // get 1() {}
      match(tt.bracketL) || // get ["string"]() {}
      match(tt.name) || // get foo() {}
      !!(state.type & TokenType.IS_KEYWORD)) // get debugger() {}
  );
}

// Returns true if this was a method.
function parseObjectMethod(isPattern, objectContextId) {
  // We don't need to worry about modifiers because object methods can't have optional bodies, so
  // the start will never be used.
  const functionStart = state.start;
  if (match(tt.parenL)) {
    if (isPattern) unexpected();
    parseMethod(functionStart, /* isConstructor */ false);
    return true;
  }

  if (isGetterOrSetterMethod(isPattern)) {
    parsePropertyName(objectContextId);
    parseMethod(functionStart, /* isConstructor */ false);
    return true;
  }
  return false;
}

function parseObjectProperty(isPattern, isBlockScope) {
  if (eat(tt.colon)) {
    if (isPattern) {
      parseMaybeDefault(isBlockScope);
    } else {
      parseMaybeAssign(false);
    }
    return;
  }

  // Since there's no colon, we assume this is an object shorthand.

  // If we're in a destructuring, we've now discovered that the key was actually an assignee, so
  // we need to tag it as a declaration with the appropriate scope. Otherwise, we might need to
  // transform it on access, so mark it as a normal object shorthand.
  let identifierRole;
  if (isPattern) {
    if (state.scopeDepth === 0) {
      identifierRole = IdentifierRole.ObjectShorthandTopLevelDeclaration;
    } else if (isBlockScope) {
      identifierRole = IdentifierRole.ObjectShorthandBlockScopedDeclaration;
    } else {
      identifierRole = IdentifierRole.ObjectShorthandFunctionScopedDeclaration;
    }
  } else {
    identifierRole = IdentifierRole.ObjectShorthand;
  }
  state.tokens[state.tokens.length - 1K(H‹Öÿ1ÂÿHˆ   H‹Óÿ}1ÂÿHÎ…ÿÿ@1ÂÿH‹ğH‹\$@H‹H‹ÈÿT¦ÁÿH‹L$HH‹H…ÀuH¨İŠÿÿâæÁÿH;ØtHN(H‹Óÿ01ÂÿH   H‹Öÿ 1ÂÿH	øÂÿH‹ÂHƒÂğÿÔ0Âÿ¹   ğÁÿÁ‰    H‹Ïÿê¥ÁÿH‹Ïÿ™¥ÁÿHâ÷Âÿÿ¤0ÂÿHõCÂÿH‹L3#ÇÿM…öu3ÀëA‹†  HX%¢ÿ€9 ‹´$°   ‰t$8L‰d$0L‰|$(‰D$ D‹    èÔşõÿM…ö„¯   Hü1~ÿÿF0ÂÿH‹ØH‹×H‹ÈèPíÿÿH˜   H‹ÓÿX0ÂÿÆG( HO I‹ÖÿG0ÂÿH‹ËèWéÿÿ÷ÆÁÿÿÿuqºæsºærsM…äuM‹e M…ÿuM‹} H‚ÿÿÜ/ÂÿH‹ØE3ÉM‹ÇI‹ÖH‹Èè°   L‹ËD‹ÆI‹ÔH‹ÏH‹HÿPXHƒÄPA_A^A]A\_^[ÃèçÖÿÿH‹Èÿş/ÂÿèiŒÿÿH‹Èÿğ/Âÿè   H‹Èÿâ/ÂÿÌÌSWHƒì(HÃ"Çÿ3Òèü–æÿH‹ØH
èÿÿT/ÂÿH‹øH‹ÓH‹Èÿ%œÁÿº €H‹Ïÿw»ÁÿH8fÄÿH‹×è–æÿH‹ÇHƒÄ(_[ÃÌÌÌÌÌÌSVWATAVAWHƒì(I‹ùM‹ğH‹òH‹ÙH‹à3}ÿHƒÂğÿæ.ÂÿH‹ï†}ÿHK8H‹ÿ
/ÂÿH‹Ëÿù£ÁÿH2‚ÿÿÄ.ÂÿL‹øH‹ÖH‹Èèş,  I‹ÖI‹ÏèC,  HKI‹ÖÿÎ.ÂÿHƒc M…ötQH‹ÏèĞşÿ‰C(ƒøtOHK0H‹×ÿ§.ÂÿI‹ÏèÇ   H‹ĞHKÿ’.ÂÿÆCH…ÀtH…ötH‹ÖH‹Ëè‘}ÿÿëÆC HƒÄ(A_A^A\_^[ÃH‹Ïè   H‹ÈÿŒ.ÂÿÌÌÌÌÌÌÌÌÌÌÌÌSWHƒì(H‹ùH°!Çÿ3Òè™•æÿH‹ØH‹ÏH‹Hÿ¨   H‹ĞH‹ËèÁæÿH‹ØH‹LôÁÿÿÖ-ÂÿH‹øH‹ÓH‹ÈÿÏyÁÿHÈdÄÿH‹×è ”æÿH‹ÇHƒÄ(_[ÃÌÌÌÌÌÌUSVWATAUAVAWHì¨   Hl$0H‰À   L‹ñE3ÿL‰}L‰}L‰yXèš*  A‹÷D‰} EgEoAƒ~(„‰	  I‹Îè(  A‹V(BÿƒøƒE	  HcÈH®ä¤ÿHcˆHÈÿáëşE9~Pu7E9~<uÿ%ÁúÑÿI‹N0A‹F8A+ÄHcĞH;Qƒ^	  H‹LÑè/  H‹ÈÿV-Âÿº   I‹Îè	  E9f8uÿ%}úÑÿèØ)  H‹Èÿ/-ÂÿE9~Pt&A‹V$E‹F D+ÂI‹Nÿ<–ÁÿH‹ÈèL  H‹Èÿ-ÂÿE‹F8E…À~8I‹N0A@ÿH˜H;AƒÛ  H‹DÁƒxuƒxuƒútèK)  H‹ÈÿÂ,ÂÿI‹ÿE‰fPBÿƒøƒc  HcÈHıã¤ÿHcˆHÈÿáëşA@ÿHcÈI‹F0H;Hƒz  Hö‚ÿÿ,ÂÿH‹øA‹F ‰D$ E‹N$M‹FI‹V@H‹Ïè™(  éá  A‹V$E‹F D+ÂI‹Nÿg•ÁÿH‹ØH…‚ÿÿÇ+ÂÿE‹Åé¿   A‹V$E‹F D+ÂI‹Nÿ:•ÁÿH‹ØHX‚ÿÿš+ÂÿA¸   é   A‹V$E‹F D+ÂI‹Nÿ
•ÁÿH‹ØH(‚ÿÿj+ÂÿA¸   ëbA‹V$E‹F D+ÂE+ÅÿÂI‹NÿØ”ÁÿH‹ØHö‚ÿÿ8+ÂÿA¸   ë0A‹V$E‹F D+ÂE+ÅÿÂI‹Nÿ¦”ÁÿH‹ØHÄ‚ÿÿ+ÂÿA¸   H‹øDˆd$ L‹ËI‹V@H‹ÈèQ   éÙ  ƒú…Ğ  I‹Îè«
  Aƒ~(	u<A‹ÔI‹ÎèI  E‹F A‹V$I‹NèØ  H‰Eº
   I‹Îè'  º   I‹Îè  ëL‰}º   I‹Îè  A¼   A‹ÔL‹µÀ   I‹Îèî  E‹F A‹V$I‹Nè}  H‹ØA‹N8A+ÌHcÑI‹N0H;Qƒ—  H[‚ÿÿ-*ÂÿH‹øL‹ML‹ÃI‹V@H‹Èè?  E3ÿEl$‹u éü  ÿÆ‰u E9~P…ë   I‹^0Ic~8GÿHcÈH;Kƒ=  H‹DËƒx…|   ƒxuvHäÿÿÿ¾)ÂÿH‹ØL|¶ÃÿI‹V@H‹Èè   H‹ÓI‹Îè  I‹~0Ic^8CA‰F8H—.~ÿÿ)ÂÿH‰EE‹ÍE3ÀAPH‹ÈècîÿH‹ÃH;_ƒ»  H‹UéD  GA‰F8HW.~ÿÿA)ÂÿH‰E E‹ÍE3ÀAP	H‹Èè#îÿH‹ÇH;{ƒ{  HOHËH‹U é  º   I‹Îè(  E‰~PI‹Îèl  H…À„í   H‹ÈÿÁÿH‹ØH¸ ‚ÿÿú˜ÁÿH‹ĞH‹Ëÿş˜Áÿ„À…À   I‹Îè^  H‹ÈHŒ ‚ÿÿŞ(ÂÿH‹ØH¼şÿÿ–(ÂÿH‹øL‹CI‹V@H‹Èèû  H‹Ïè3  I‹Îƒøÿt‹Ğè  H‹ĞI‹ÎèÙ  éš  H‹×èÌ  I‹~0Ic^8CA‰F8HN-~ÿÿ8(ÂÿH‰E(E‹ÍE3ÀAPH‹ÈèŒîÿH‹ÃH;_ƒr  H‹U(HKHÏÿ3(Âÿé¦úÿÿè!  H‹ÈÿX(ÂÿE9~Ptº   I‹Îè  A‹F8A;ÄèG  H‹Èÿ.(ÂÿÿÈA‰F8I‹N0H˜H;Aƒ  H‹DÁE9~PuƒxtH‹ÈèÏ  H‹Èÿö'ÂÿƒxuGE9~PtyI‹Îè"  H‹øI‹Îè  H‹ÈH…ıÿÿ—'ÂÿH‹ØD88H‹×H‹Èè6  H‹Ëè  H‹Óë0I‹Îèá  H‹ØH ‚ÿÿ)'ÂÿH‹øL‹ËE3ÀI‹V@H‹Èè\  H‹×I‹Îè  E‰nPÿÎ‰u é£ùÿÿE9~PuHŸÅÿè¡  H‹ÈÿH'Âÿº   I‹Îèû  I‹N0A‹F8A+ÄH˜H;Aƒ  H‹DÁƒxtèÔ  H‹Èÿ'ÂÿI‹ÎèC  H‹øI‹Îè8  H‹ÈH¦üÿÿ¸&ÂÿH‹ØD88H‹×H‹ÈèW  H‹ÓI‹ÎèÜ  E‰~PéùÿÿA‹N,E9~P…—   ƒùuqE‰n,I‹F0H‰E@Icv8FA‰F8A‹~,‹Ïèş  ‹ØH-+~ÿÿ&ÂÿH‰EHD‹ËD‹ÇA‹ÔH‹Èèú‰îÿH‹ÎH‹E@H;pƒN  H‹UHHƒÁHÈÿ&Âÿ‹u éøÿÿƒùuE‰f,ëˆè¿  H‹Èèw  H‹Èÿ&ÂÿE‰~Pè…  ‹ĞI‹ÎèË  I‹F0H‰E0Icv8FA‰F8A‹~,‹Ïè]  ‹ØHŒ*~ÿÿv%ÂÿH‰E8D‹ËD‹Çº   H‹ÈèW‰îÿH‹ÎH‹E0H;pƒ«  H‹U8ÿ%óòÑÿE9~Pt&A‹V$E‹F D+ÂI‹Nÿ¸ÁÿH‹ÈèÈ  H‹Èÿ%ÂÿI‹~0Ic^8CA‰F8H*~ÿÿû$ÂÿH‰EPA¹   E‹F,AQíH‹ÈèÙˆîÿH‹ÃH;_ƒ1  HKHÏH‹UPÿò$ÂÿE‰nPéa÷ÿÿI‹Îè)  H…À„­   H‹Èÿ×™ÁÿH‹ØHuüÿÿ·”ÁÿH‹ĞH‹Ëÿ³”Áÿ„À„€   I‹ÎèK  E9f(urI‹Îè  H‹ÈH;üÿÿ$ÂÿH‹XE‹F A‹V$I‹Nèh  HÙ¸ÃÿL‹ÀH‹Ëÿ}ÁÿH‹ØHüÿÿ$ÂÿH‹øL‹ÃI‹V@H‹Èè  H‹×I‹Îèx  é£öÿÿA‹V$E‹F D+ÂI‹NÿvÁÿA‹V$ÿÂH‹Èè   H‹Èÿ7$ÂÿI‹VHL9zv"H‹RINXÿç#ÂÿH‹ÂHexA_A^A]A\_^[]ÃÿmÛÁÿÌHƒì8H‹óÁÿÿk$ÂÿH…Àu3ÉëH‰EH‹Mè­wşÿ3É„À•Á‹ÁHƒÄ8ÃHƒì8è   H‹Èÿ½#ÂÿHĞøÿÿHƒÄ8ÃÌHƒì(H%Çÿ3ÒèÎŠæÿH‹Èè   HƒÄ(ÃSWHƒì(H‹ùHPøÿÿ#ÂÿH‹ØH‹×H‹ÈÿãÁÿº €H‹Ëÿ5¯ÁÿHöYÄÿH‹ÓèÎ‰æÿH‹ÃHƒÄ(_[ÃÌÌÌÌSWHƒì(‰T$HH‹ùHìÇÿ3ÒèUŠæÿH‹Øÿ„ËÁÿH‹ĞHL$Hÿ6‚ÁÿL‹ÀH‹×H‹Ëè€±æÿH‹ÈèhÿÿÿHƒÄ(_[ÃSVWHƒì H‹úHcY<ƒûb}8C‰A<H‹qHH‹Îÿª"ÂÿH;^sHNHÙH‹×ÿ{"ÂÿHƒÄ _^[ÃÿÚÁÿè   H‹Èÿ—"ÂÿÌÌÌÌÌÌÌHƒì(H}Çÿ3Òè®‰æÿH‹Èèf9ÿÿHƒÄ(ÃSWHƒì(I‹øH‹ÙèßuóÿHKH‹×ÿ"ÂÿHƒÄ(_[ÃÌÌÌÌÌÌÌÌÌÌÌSVWAUAVAWHƒì8A‹øHcÚH‹ñ‹Ó‰\$ ‹Ï‰L$$H‹ÃH;^ƒó   fƒ|^`uƒÃ€  ƒï€ş   D‹÷HÕ„Äÿë)fƒ|^[…   ƒÃ€İ   D‹÷Aƒîxpression() {
  expectContextual(ContextualKeyword._module);
  expect(tt.braceL);
  // For now, just call parseBlockBody to parse the block. In the future when we
  // implement full support, we'll want to emit scopes and possibly other
  // information.
  parseBlockBody(tt.braceR);
}
