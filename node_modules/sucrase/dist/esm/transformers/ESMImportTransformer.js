


import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";

import elideImportEquals from "../util/elideImportEquals";
import getDeclarationInfo, {

  EMPTY_DECLARATION_INFO,
} from "../util/getDeclarationInfo";
import getImportExportSpecifierInfo from "../util/getImportExportSpecifierInfo";
import {getNonTypeIdentifiers} from "../util/getNonTypeIdentifiers";
import isExportFrom from "../util/isExportFrom";
import {removeMaybeImportAttributes} from "../util/removeMaybeImportAttributes";
import shouldElideDefaultExport from "../util/shouldElideDefaultExport";

import Transformer from "./Transformer";

/**
 * Class for editing import statements when we are keeping the code as ESM. We still need to remove
 * type-only imports in TypeScript and Flow.
 */
export default class ESMImportTransformer extends Transformer {
  
  
  

  constructor(
     tokens,
     nameManager,
     helperManager,
     reactHotLoaderTransformer,
     isTypeScriptTransformEnabled,
     isFlowTransformEnabled,
     keepUnusedImports,
    options,
  ) {
    super();this.tokens = tokens;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.keepUnusedImports = keepUnusedImports;;
    this.nonTypeIdentifiers =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? getNonTypeIdentifiers(tokens, options)
        : new Set();
    this.declarationInfo =
      isTypeScriptTransformEnabled && !keepUnusedImports
        ? getDeclarationInfo(tokens)
        : EMPTY_DECLARATION_INFO;
    this.injectCreateRequireForImportRequire = Boolean(options.injectCreateRequireForImportRequire);
  }

  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {
      return this.processImportEquals();
    }
    if (
      this.tokens.matches4(tt._import, tt.name, tt.name, tt.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 8 tokens long, so remove the 7 remaining tokens.
      for (let i = 0; i < 7; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches2(tt._export, tt.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (
      this.tokens.matches5(tt._export, tt._import, tt.name, tt.name, tt.eq) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._type)
    ) {
      // export import type T = require('T')
      this.tokens.removeInitialToken();
      // This construct is always exactly 9 tokens long, so remove the 8 remaining tokens.
      for (let i = 0; i < 8; i++) {
        this.tokens.removeToken();
      }
      return true;
    }
    if (this.tokens.matches1(tt._import)) {
      return this.processImport();
    }
    if (this.tokens.matches2(tt._export, tt._default)) {
      return this.processExportDefault();
    }
    if (this.tokens.matches2(tt._export, tt.braceL)) {
      return this.processNamedExports();
    }
    if (
      this.tokens.matches2(tt._export, tt.name) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // export type {a};
      // export type {a as b};
      // export type {a} from './b';
      // export type * from './b';
      // export type * as ns from './b';
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(tt.braceL)) {
        while (!this.tokens.matches1(tt.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        // *
        this.tokens.removeToken();
        if (this.tokens.matches1(tt._as)) {
          // as
          this.tokens.removeToken();
          // ns
          this.tokens.removeToken();
        }
      }
      // Remove type re-export `... } from './T'`
      if (
        this.tokens.matchesContextual(ContextualKeyword._from) &&
        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)
      ) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        removeMaybeImportAttributes(this.tokens);
      }
      return true;
    }
    return false;
  }

   processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.shouldAutomaticallyElideImportedName(importName)) {
      // If this name is only used as a type, elide the whole import.
      elideImportEquals(this.tokens);
    } else if (this.injectCreateRequireForImportRequire) {
      // We're using require in an environment (Node ESM) that doesn't provide
      // it as a global, so generate a helper to import it.
      // import -> const
      this.tokens.replaceToken("const");
      // Foo
      this.tokens.copyToken();
      // =
      this.tokens.copyToken();
      // require
      this.tokens.replaceToken(this.helperManager.getHelperName("require"));
    } else {
      // Otherwise, just switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }

   processImport() {
    if (this.tokens.matches2(tt._import, tt.parenL)) {
      // Dynamic imports don't need to be transformed.
      return false;
    }

    const snapshot = this.tokens.snapshot();
    const allImportsRemoved = this.removeImportTypeBindings();
    if (allImportsRemoved) {
      this.tokens.restoreToSnapshot(snapshot);
      while (!this.tokens.matches1(tt.string)) {
        this.tokens.removeToken();
      }
      this.tokens.removeToken();
      removeMaybeImportAttributes(this.tokens);
      if (this.tokens.matches1(tt.semi)) {
        this.tokens.removeToken();
      }
    }
    return true;
  }

  /**
   * Remove type bindings from this import, leaving the rest of the import intact.
   *
   * Return true if this import was ONLY types, and thus is eligible for removal. This will bail out
   * of the replacement operation, so we can return early here.
   */
   removeImportTypeBindings() {
    this.tokens.copyExpectedToken(tt._import);
    if (
      this.tokens.matchesContextual(ContextualKeyword._type) &&
      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&
      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)
    ) {
      // This is an "import type" statement, so exit early.
      return true;
    }

    if (this.tokens.matches1(tt.string)) {
      // This is a bare import, so we should proceed with the import.
      this.tokens.copyToken();
      return false;
    }

    // Skip the "module" token in import reflection.
    if (
      this.tokens.matchesContextual(ContextualKeyword._module) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 2, ContextualKeyword._from)
    ) {
      this.tokens.copyToken();
    }

    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    let needsComma = false;

    // Handle default import.
    if (this.tokens.matches1(tt.name)) {
      if (this.shouldAutomaticallyElideImportedName(this.tokens.identifierName())) {
        this.tokens.removeToken();
        if (this.tokens.matches1(tt.comma)) {
          this.tokens.removeToken();
        }
      } else {
        foundNonTypeImport = true;
        this.tokens.copyToken();
        if (this.tokens.matches1(tt.comma)) {
          // We're in a statement like:
          // import A, * as B from './A';
          // or
          // import A, {foo} from './A';
          // where the `A` is being kept. The comma should be removed if an only
          // if the next part of the import statement is elided, but that's hard
          // to determine at this point in the code. Instead, always remove it
          // and set a flag to aƒÄ [ÃÌÌÌÌÌÌÌÌÌÌÌSHƒì H|GÑÿÿ>qĞÿH_˜ĞÿH‹ØHƒ¸@   uH‹³>ĞÿÿMáÏÿH‰ƒ@  H‹ƒ@  HƒÄ [ÃÌÌÌÌÌÌÌÌÌSHƒì H,GÑÿÿîpĞÿH˜ĞÿH‹ØHƒ¸¨    uH‹»EĞÿÿıàÏÿH‰ƒ¨   H‹ƒ¨   HƒÄ [ÃÌÌÌÌÌÌÌÌÌSHƒì H‹Ùè3  „ÀuH‹Ëè  „ÀtH‹ÃëA°AŠĞH‹Ëè   HƒÄ [ÃÌÌÌÌÌÌÌÌÌSVWATAUAVAWHƒì`Dˆ„$°   ˆ”$¨   ŠÚH‹ùE3ÿD‰|$(D‰|$$D‰|$,ÿÚÏÿ„ÀtH‹ÇéH  D8?H‹ÏÿÕÜÏÿD‹èfº_ H‹ÏÿeÜÏÿD‹ğM‹ç…ÀxmH¼HÑÿÿöoĞÿHœĞÿH‹ğH‹HH…Éu+H‹„3ĞÿÿŞoĞÿH‹ØH#ÔÿH‹Èÿó¶ÏÿH‰^Šœ$¨   H‹ND89E‹ÆH‹×ÿ·ÏÿD88H‹ÈÿIµÏÿL‹àƒL$ ÿM…ät@I‹ÌL¢7İÿAÿ„Àt/I‹ÌLa9İÿAÿH‹ÈH‹L1ĞÿÿoĞÿD88H‹Èÿ²ÏÿÿÈ‰D$ A‹÷E3ö„Û„é  H÷GÑÿÿ1oĞÿHR›ĞÿH‰D$P‹_…Û„J  3ÒH‹Ïÿ¿ÛÏÿ·ĞH‹L$Pèb  „Àu@8´$°   u3ÒH‹Ïÿ™ÛÏÿfƒø:u
9t$ …„  H‹BCĞÿÿÔnĞÿL‹ğAUH‹Èÿ¬ĞÿHe"ÔÿI‹ÎÿôĞÿA¿   E;ï¬   …Û„Å  3ÒH‹Ïÿ:ÛÏÿ·À- Ø  =ÿ  ‡†   D;ûƒ  A‹×H‹ÏÿÛÏÿ·À- Ü  =ÿ  wb3ÒH‹ÏÿøÚÏÿ·ØA‹×H‹ÏÿéÚÏÿ·Èé Ü  ƒ@(ÿÿÁà
È‰L$(ÿóĞÿHä!ÔÿL‹ÀHL$(ÿ¦ÍÏÿH‹ĞI‹ÎÿBĞÿA‹÷D~ëA…Û„  3ÒH‹ÏÿÚÏÿ·À‰D$$ÿ©ĞÿHº!ÔÿL‹ÀHL$$ÿ\ÍÏÿH‹ĞI‹ÎÿøĞÿfº_ I‹ÎÿĞÿÿÆƒ|$  uEA€<$ I‹ÌL»5İÿAÿ„Àt/I‹ÌLz7İÿAÿH‹ÈH‹U/Ğÿÿ§mĞÿ€8 H‹Èÿ#°ÏÿÿÈ‰D$ A;õ7  HFÑÿÿ?mĞÿH`™ĞÿH‰D$8I‹ÌH97İÿÿkmĞÿH‰D$X‹_€¼$°    t&;óƒ9  ‹ÖH‹Ïÿ®ÙÏÿ·ÈH‹D$8H‹ ö v0ë$;óƒ  ‹ÖH‹ÏÿˆÙÏÿ·ĞH‹L$8è  „Àt
9t$ …  M…öuH‹!AĞÿÿ³lĞÿL‹ğAE‹ĞI‹Îÿ‰Ğÿ9t$ u@A€<$ I‹ÌLÄ4İÿAÿ„Àt*I‹ÌHÿT$XH‹ÈH‹S.Ğÿÿ¥lĞÿ€8 H‹Èÿ!¯ÏÿÿÈ‰D$ D‹ÎE+ÏE‹ÇH‹×I‹ÎÿĞÿHçÔÿI‹ÎÿvĞÿD~E;ï³   ;óƒI  ‹ÖH‹Ïÿ¾ØÏÿ·À- Ø  =ÿ  ‡   A‹Ç‰D$0D;ûƒ  ‹ĞH‹ÏÿØÏÿ·À- Ü  =ÿ  wc‹ÖH‹ÏÿvØÏÿ·ØA‹×H‹ÏÿgØÏÿ·Èé Ü  ƒ@(ÿÿÁà
È‰L$,ÿqĞÿHbÔÿL‹ÀHL$,ÿ$ËÏÿH‹ĞI‹ÎÿÀĞÿD~‹t$0ëA;óƒ–   ‹ÖH‹ÏÿØÏÿ·À‰D$$ÿ&ĞÿH7ÔÿL‹ÀHL$$ÿÙÊÏÿH‹ĞI‹ÎÿuĞÿfº_ I‹Îÿ˜ĞÿÿÆA;õŒ÷ıÿÿE…ÿ„ÛúÿÿE;ı}E+ïA€> E‹ÍE‹ÇH‹×I‹Îÿ>ĞÿA€> I‹ÎÿéĞÿHƒÄ`A_A^A]A\_^[Ãÿ¢"ĞÿÌÌÌÌÌÌÌÌÌÌD·ÂH‹Aö  w	fƒú:”Àë°ÃÌÌÌÌÌÌD·ÂH‹Aö w	fƒú_”Àë°ÃÌÌÌÌÌÌUHƒì0Hl$ Hƒe ÆE  º   èS   ÆE ŠE He]ÃHƒì(ÆE  HèÿÿÿHƒÄ(ÃHƒì(H‰MèI÷ÿ„Àtÿ“jĞÿÆE  HÁÿÿÿHƒÄ(ÃÌÌÌÌÌÌÌÌÌÌÌSVWHƒì ‹òH‹ÙH…Ût.ÿ±ÖÏÿ…Àt23ÒH‹ËèÛöÿ‹øH‹Ëÿ˜ÖÏÿ;øu'H‹ÃHƒÄ _^[Ãè\@úÿH‹Èÿ3jĞÿè.   H‹Èÿ%jĞÿD‹Æ‹×H‹ËèHûÿH‹ÈÿjĞÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌHƒì(H•Ôÿè0ûÿHƒÄ(ÃÌÌÌÌÌÌÌÌÌÌSVWHƒì0H‹Ù€9 ÿÖÏÿ…Àu
2ÀHƒÄ0_^[Ãƒ{ vt3ÒH‹ËÿîÕÏÿ·Èèv   „ÀtÙH‹ËÿáÕÏÿƒø~H¿   ;{sE‹×H‹Ëÿ¿ÕÏÿ·ğ·ÈèD   „Àufƒş0r	fƒş9–Àë2À„Àt’ÿÇH‹Ëÿ˜ÕÏÿ;ø|½°é~ÿÿÿÿ§ ĞÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌA¿fƒøw°ëfƒùar	fƒùz–Àë2ÀÃÌSVWHƒì H‹òH‹ùÿ½İÏÿHF»‘ÿÿˆhĞÿH‹ØH‹ÖH‹Èè"   HOH‹ÓÿhĞÿHƒÄ _^[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌSWHƒì(H‹úH‹ÙH>Ñÿÿ7hĞÿHX‘ĞÿHK8H‹ÿ[hĞÿH‹ËÿJİÏÿÆCHKH‹×ÿAhĞÿHƒÄ(_[ÃÌÌSWHƒì(H‹ù3Òÿ_	Ğÿ„Àt)H‹ÏH‹HÿPHH‹ØH‹ÏH‹HÿP@H‹ĞH‹Ëè   „À”Àë2ÀHƒÄ(_[ÃÌÌÌÌÌÌÌÌÌSVWATAUAVAWHƒì@H‰”$ˆ   èT  H‹øH‰D$(Hu=ÑÿÿgĞÿH˜ŒĞÿL‹0A€> H…ÿu	OÿëôÏÿI‹^I‹vH…Û„Ê  E3ÿI‹F(H‰D$0H…À…Ú   D8?H‹ÏÿQÒÏÿD‹èAºõAı   €u
ƒ{ÿ„   A‹Å™÷{HcÂH;Cƒ’  ‹\ƒÿËH‹íZĞÿH‹H‰L$ H…ÉuH‹ÑZĞÿÿ³ĞÿH‹ÈH‰D$ D‹fëZHcûH;~ƒP  HD9lÆuHL‹D$(H‹TÆH‹HÿP@„À…à   H;~ƒ  H‹\ÆE;ü|ÿ+ôÏÿAÿÇH‹L$ A;Üsÿ%@'àÿé«   H‹×H‹ÈL¶4İÿAÿD‹àAºôAü   €u
ƒ{ÿ„Â   A‹Ä™÷{HcÂH;Cƒ´   ‹\ƒÿËD‹nëUHcûH;~ƒ›   HD9dÆu!HL‹D$(H‹TÆH‹L$0L0İÿAÿ„Àu'H;~siH‹\ÆE;ı|ÿvóÏÿAÿÇA;İsÿ%˜&àÿ…Ûx,I‹VHcÃH;Bs7H@HÌM°ÿL‹„$ˆ   H‹TÂ è*   ë2ÀHƒÄ@A_A^A]A\_^[Ãÿ@ĞÿÿBĞÿÌÌÌÌÌÌÌÌÌÌSVWHƒì H‰L$@I‹ØH‹úH‹t$@H‹ÏH‹öÂtH‹Rÿÿ$fĞÿH…ÀuH‹NöÁtH‹IÿE3ÉL‹ÃH‹×è$   ëH‹ÓH‹ÈL‹T$@M‹RAÿHƒÄ _^[ÃÌÌÌÌÌÌÌUSVWATAVAWHƒì@Hl$ H‰M`I‹ùM‹øH…ÒuH×ÒÿÿÉ©ÏÿH‹Èÿ(eĞÿÆE  H‹ÊH…ÿ…–   L‹e`L‹U`M‹AÿH‹ØH‰EI‹D$H‹ H‹ğH‹ËHÎ,İÿÿÀdĞÿL‹ğ€; H‹ËIÿÖ„ÀtOH‹ËL‹U`M‹RAÿH‹øH‹H…ÀuI‹L$öÁtH‹IÿÿĞÿM‹ÇH‹×H‹ÈH‹HÿP@„Àt²ÆE è—   é€   è   ëpL‹U`M‹AÿH‹ØH‰EH‹ËHW,İÿÿ9dĞÿH‹ğ€; H‹ËHÿÖ„Àt,H‹ËL‹U`M‹RAÿM‹ÇH‹ĞH‹ÏL‹U`M‹R Aÿ„ÀtÍÆE ëH‹MH…Ét
L,İÿAÿ2Àëè/   ŠE He A_A^A\_^[]ÃHƒì(H‹MH…Ét
Ló+İÿAÿHƒÄ(ÃHƒì(H‹MH…Ét
Læ+İÿAÿHƒÄ(ÃÌÌÌÌÌÌÌÌÌÌÌÌÌSHƒì H‹ÙH‹Hÿ  „Àt#H‹ËH‹Hÿø   „ÀuH‹ËH‹HÿP  H‹ÈëH‹ËH‹Hÿ¨   HƒÄ [ÃÌÌÌSVWATAUAVAWHƒì0èœÿÿÿL‹àH‰D$ H½8ÑÿÿÇbĞÿHà‡ĞÿH‹8€? M…äuAL$ÿ2ğÏÿƒËÿL‹wH‹wM…ö„Ø   E3ÿL‹o(M…í…à   E8<$I‹Ìÿ™ÍÏÿD‹àAºôAü   €u
A9^„j  A‹Ä™A÷~HcÂI;FƒO  A‹\†ÿËH‹3VĞÿL‹(M…íuH‹VĞÿÿşĞÿL‹èD‹vëTHcûH;~ƒ  HD9dÆuHL‹D$ H‹TÆI‹ÍH‹HÿP@„Àu+H;~ƒå   H‹\ÆE;ş|ÿ|ïÏÿAÿÇA;Şsÿ%¦"àÿÁë€óŠÃHƒÄ0A_A^A]A\_^[ÃI‹ÔI‹ÍL	0İÿAÿD‹àAºôAü   €u
A9^„‡   A‹Ä™A÷~HcÂI;FspA‹\†ÿËD‹v also need to handle implicit export elision for names declared as
   * types. In the second case, we must NOT do implicit named export elision,
   * but we must remove the runtime import if all exports are type exports.
   */
   processNamedExports() {
    if (!this.isTypeScriptTransformEnabled) {
      return false;
    }
    this.tokens.copyExpectedToken(tt._export);
    this.tokens.copyExpectedToken(tt.braceL);

    const isReExport = isExportFrom(this.tokens);
    let foundNonTypeExport = false;
    while (!this.tokens.matches1(tt.braceR)) {
      const specifierInfo = getImportExportSpecifierInfo(this.tokens);
      if (
        specifierInfo.isType ||
        (!isReExport && this.shouldElideExportedName(specifierInfo.leftName))
      ) {
        // Type export, so remove all tokens, including any comma.
        while (this.tokens.currentIndex() < specifierInfo.endIndex) {
          this.tokens.removeToken();
        }
        if (this.tokens.matches1(tt.comma)) {
          this.tokens.removeToken();
        }
      } else {
        // Non-type export, so copy all tokens, including any comma.
        foundNonTypeExport = true;
        while (this.tokens.currentIndex() < specifierInfo.endIndex) {
          this.tokens.copyToken();
        }
        if (this.tokens.matches1(tt.comma)) {
          this.tokens.copyToken();
        }
      }
    }
    this.tokens.copyExpectedToken(tt.braceR);

    if (!this.keepUnusedImports && isReExport && !foundNonTypeExport) {
      // This is a type-only re-export, so skip evaluating the other module. Technically this
      // leaves the statement as `export {}`, but that's ok since that's a no-op.
      this.tokens.removeToken();
      this.tokens.removeToken();
      removeMaybeImportAttributes(this.tokens);
    }

    return true;
  }

  /**
   * ESM elides all imports with the rule that we only elide if we see that it's
   * a type and never see it as a value. This is in contrast to CJS, which
   * elides imports that are completely unknown.
   */
   shouldElideExportedName(name) {
    return (
      this.isTypeScriptTransformEnabled &&
      !this.keepUnusedImports &&
      this.declarationInfo.typeDeclarations.has(name) &&
      !this.declarationInfo.valueDeclarations.has(name)
    );
  }
}
