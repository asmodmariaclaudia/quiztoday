


import {isDeclaration} from "./parser/tokenizer";
import {ContextualKeyword} from "./parser/tokenizer/keywords";
import {TokenType as tt} from "./parser/tokenizer/types";

import getImportExportSpecifierInfo from "./util/getImportExportSpecifierInfo";
import {getNonTypeIdentifiers} from "./util/getNonTypeIdentifiers";
















/**
 * Class responsible for preprocessing and bookkeeping import and export declarations within the
 * file.
 *
 * TypeScript uses a simpler mechanism that does not use functions like interopRequireDefault and
 * interopRequireWildcard, so we also allow that mode for compatibility.
 */
export default class CJSImportProcessor {
   __init() {this.nonTypeIdentifiers = new Set()}
   __init2() {this.importInfoByPath = new Map()}
   __init3() {this.importsToReplace = new Map()}
   __init4() {this.identifierReplacements = new Map()}
   __init5() {this.exportBindingsByLocalName = new Map()}

  constructor(
     nameManager,
     tokens,
     enableLegacyTypeScriptModuleInterop,
     options,
     isTypeScriptTransformEnabled,
     keepUnusedImports,
     helperManager,
  ) {;this.nameManager = nameManager;this.tokens = tokens;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.options = options;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.keepUnusedImports = keepUnusedImports;this.helperManager = helperManager;CJSImportProcessor.prototype.__init.call(this);CJSImportProcessor.prototype.__init2.call(this);CJSImportProcessor.prototype.__init3.call(this);CJSImportProcessor.prototype.__init4.call(this);CJSImportProcessor.prototype.__init5.call(this);}

  preprocessTokens() {
    for (let i = 0; i < this.tokens.tokens.length; i++) {
      if (
        this.tokens.matches1AtIndex(i, tt._import) &&
        !this.tokens.matches3AtIndex(i, tt._import, tt.name, tt.eq)
      ) {
        this.preprocessImportAtIndex(i);
      }
      if (
        this.tokens.matches1AtIndex(i, tt._export) &&
        !this.tokens.matches2AtIndex(i, tt._export, tt.eq)
      ) {
        this.preprocessExportAtIndex(i);
      }
    }
    this.generateImportReplacements();
  }

  /**
   * In TypeScript, import statements that only import types should be removed.
   * This includes `import {} from 'foo';`, but not `import 'foo';`.
   */
  pruneTypeOnlyImports() {
    this.nonTypeIdentifiers = getNonTypeIdentifiers(this.tokens, this.options);
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      if (
        importInfo.hasBareImport ||
        importInfo.hasStarExport ||
        importInfo.exportStarNames.length > 0 ||
        importInfo.namedExports.length > 0
      ) {
        continue;
      }
      const names = [
        ...importInfo.defaultNames,
        ...importInfo.wildcardNames,
        ...importInfo.namedImports.map(({localName}) => localName),
      ];
      if (names.every((name) => this.shouldAutomaticallyElideImportedName(name))) {
        this.importsToReplace.set(path, "");
      }
    }
  }

  shouldAutomaticallyElideImportedName(name) {
    return (
      this.isTypeScriptTransformEnabled &&
      !this.keepUnusedImports &&
      !this.nonTypeIdentifiers.has(name)
    );
  }

   generateImportReplacements() {
    for (const [path, importInfo] of this.importInfoByPath.entries()) {
      const {
        defaultNames,
        wildcardNames,
        namedImports,
        namedExports,
        exportStarNames,
        hasStarExport,
      } = importInfo;

      if (
        defaultNames.length === 0 &&
        wildcardNames.length === 0 &&
        namedImports.length === 0 &&
        namedExports.length === 0 &&
        exportStarNames.length === 0 &&
        !hasStarExport
      ) {
        // Import is never used, so don't even assign a name.
        this.importsToReplace.set(path, `require('${path}');`);
        continue;
      }

      const primaryImportName = this.getFreeIdentifierForPath(path);
      let secondaryImportName;
      if (this.enableLegacyTypeScriptModuleInterop) {
        secondaryImportName = primaryImportName;
      } else {
        secondaryImportName =
          wildcardNames.length > 0 ? wildcardNames[0] : this.getFreeIdentifierForPath(path);
      }
      let requireCode = `var ${primaryImportName} = require('${path}');`;
      if (wildcardNames.length > 0) {
        for (const wildcardName of wildcardNames) {
          const moduleExpr = this.enableLegacyTypeScriptModuleInterop
            ? primaryImportName
            : `${this.helperManager.getHelperName("interopRequireWildcard")}(${primaryImportName})`;
          requireCode += ` var ${wildcardName} = ${moduleExpr};`;
        }
      } else if (exportStarNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireWildcard",
        )}(${primaryImportName});`;
      } else if (defaultNames.length > 0 && secondaryImportName !== primaryImportName) {
        requireCode += ` var ${secondaryImportName} = ${this.helperManager.getHelperName(
          "interopRequireDefault",
        )}(${primaryImportName});`;
      }

      for (const {importedName, localName} of namedExports) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createNamedExportFrom",
        )}(${primaryImportName}, '${localName}', '${importedName}');`;
      }
      for (const exportStarName of exportStarNames) {
        requireCode += ` exports.${exportStarName} = ${secondaryImportName};`;
      }
      if (hasStarExport) {
        requireCode += ` ${this.helperManager.getHelperName(
          "createStarExport",
        )}(${primaryImportName});`;
      }

      this.importsToReplace.set(path, requireCode);

      for (const defaultName of defaultNames) {
        this.identifierReplacements.set(defaultName, `${secondaryImportName}.default`);
      }
      for (const {importedName, localName} of namedImports) {
        this.identifierReplacements.set(localName, `${primaryImportName}.${importedName}`);
      }
    }
  }

  getFreeIdentifierForPath(path) {
    const components = path.split("/");
    const lastComponent = components[components.length - 1];
    const baseName = lastComponent.replace(/\W/g, "");
    return this.nameManager.claimFreeName(`_${baseName}`);
  }

   preprocessImportAtIndex(index) {
    const defaultNames = [];
    const wildcardNames = [];
    const namedImports = [];

    index++;
    if (
      (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._type) ||
        this.tokens.matches1AtIndex(index, tt._typeof)) &&
      !this.tokens.matches1AtIndex(index + 1, tt.comma) &&
      !this.tokens.matchesContextualAtIndex(index + 1, ContextualKeyword._from)
    ) {
      // import type declaration, so no need to process anything.
      return;
    }

    if (this.tokens.matches1AtIndex(index, tt.parenL)) {
      // Dynamic import, so nothing to do
      return;
    }

    if (this.tokens.matches1AtIndex(index, tt.name)) {
      defaultNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
      if (this.tokens.matches1AtIndex(index, tt.comma)) {
        index++;
      }
    }

    if (this.tokens.matches1AtIndex(index, tt.star)) {
      // * as
      index += 2;
      wildcardNames.push(this.tokens.identifierNameAtIndex(index));
      index++;
    }

    if (this.tokens.matches1AtIndex(index, tt.braceL)) {
      const result = this.getNamedImports(index + 1);
      index = result.newIndex;

      for (const namedImport of result.namedImports) {
        // Treat {default as X} as a default import to ensure usage of require interop helper
        if (namedImport.importedName === "default") {
          defaultNames.push(namedImport.localName);
        } else {
          namedImports.push(namedImport);
        }
      }
    }

    if (this.tokens.matchesContextualAtIndex(index, ContextualKeyword._from)) {
      index++;
    }

    if (!this.tokens.matches1AtIndex(index, tt.string)) {
      throw new Error("Expected string token at the end of import statement.");
    }
    const path = this.tokens.stringValueAtIndex(index);
    c@Áx ˜ÿ …¤@˜ ¯ÿ …¥@ ÜÁÜAÿ …©@a­¥˜ÿ †$İÌ³Ì›Ìÿ †& õ• ™ ” ÿ ‡(¨••›Ùÿ ˆ&E˜#¦;H0ÿ ˆ+F²S„•¾jÿ ‰)Gµ•Ñ•Ñ¥Ùÿ Š&š(µ ˜ ² ° ÿ Š+,­Ó‘Ó›éÿ +×*©
1]Œyÿ ‘&TÏIÆ©F¦ ÿ¤š‘­­‘´´ ÿ6© %%%¢ ÿ	C²9S7qCŒbÿa®CbÄU6¤¤¤ÿõµ¬¢Ç¤ÿ/œ À8¿L‹LLP0ÿ¬²¡‘Á -&-&ÿ<WT4†4†ÿ¥KSSSÿSå9µÏÓ2Åÿ|¢bb™îî€Ìx˜ÿá£-B¡Ñœ³†ÿt× 8› 
¦ 8› 
ÿH8Ÿ0000ÿ¥Ÿ¡›DDoMhÿy`b‚‚ššEÿ+M» ´ ¬  ³ ¤ ÿQ!9µÔÓ2Íÿ!	¡gœj§rcÿy
m€`şRŒ‰‰R†Rÿ!>®¡¡­í‰íÿy
€4şRŒ‰‰R†Rÿ!á¤N°*ÌÛŸ—Õÿ!‰¤}´}É}º.ÿ!e®CbÅU6¤¤¤ÿ!Ğ˜]”éŸc'ª¤ÿ!PPïÍ‰˜‰¡ÿ%˜ËU‹U‰U‹Uÿ)­Š7fŠ6›Uÿ)z",L45<¡ÿ)
†
¡º
fvÿ)¤yÅÑ¿YÃ ¶ ÿ)$ ³ã£‘¦–¦¨ÿ)0”<•*¯@Ğf› *ÿ-¥
˜
m™Ÿÿ-l'W'RŠCoÿv©ù‹ù€üş³“ÿ1Ÿ›h¦ C@™ @ÿ1]™ˆÓ$ˆ¡ÿ5¡gj¤j©ÿ5­ÁŒÁ¦ ¶¡ÿ5™
'±,$20ÿ5uÀu7Œƒ%¤ˆ¤¤ÿ9¢–Œ¡©
 
$Ÿ ÿ9œs*œˆ*™ÿ=EëÜ©€{× ÿ=!iß
œ#j’“{ÿv¡Ÿ$W›JSKÿ=!iß
œ3^’3>ÿ=!iß
œsR’“cÿv£óLœ£¡ˆóLÿ=!iß
œ³S’Ã`ÿ=!iß
œ³d’çÿA-¨°—°’Q°°ÿA}¨°—°•°œQ°ÿE	¢¨jŒj¬‰Š‰ÿE	²Å“Ÿ 
© Ÿ 
ÿE	Ò¯‘Í)£í˜íÿE]½.©íœq™<·
ÿM°¥*@¤.’n£3ÿQ!£e&’e&še&˜¢ÿQ-Ÿ66œ–ŠLLÿQUšn•nnŸn’nxÿQt @©
ˆSˆx2ÿQ
M¢££·ÿQ
äÀNî–î¥b£b.ÿQ
øº%Œ%™%%ÿU”n–NDŸK£okÿU%¥á~Œá~•á~©ÓŒÿU6©Ñ=ŒÑ=™Ñ=©c¹ÿX¹™«*S22ˆÿXé2"[ŠZZz£bÿY	ª°›°Ÿ°´Mİ°ÿY	Uœ Ûq± ­
"ÿY	¥©“©‘©§©ÿY:Ã.–aDŒÁD›‹ÿ]µ@™ © ¢ ¡ ³ ÿ]ñÆ‡ ¢‡6ÿv™k™#oW+(ÿqIò3xÂ{áuÿm©¥ ™—+wÿmq¢˜"
ª ÿi6¡f–f˜…‘Ì‚”°ÿiÈ—ä™ä™ä¯“¸‰ÿi©
™H› é ¿ ÿec#sŠ soÿ]P²9S7–qCŒbÿ]ËY¢œ¢~–¢ÿ±öÕ¥Ÿ 
© Ÿ 
ÿ±²Å“ÆŸ 
© Ÿ 
ÿ±²Å“•ÌŸ 
© Ÿ 
ÿ±²Å“q2Ÿ 
© Ÿ 
ÿ±²Å“i7Ÿ 
© Ÿ 
ÿ±¡Îœ¢	{;ÿ­u¾[®e&«Á£{Fÿ­¤¯õ¹À ˆjÿ©OÁ=$…=$Å[ß—¨ÿ©ª–Œ¡ºmŒ-™mÿ©¦
]%5Š
<§
® ÿ©‘.….“.‘..n“Nÿ¥\²±³j3’Ê!ÿ¥B½¸Š¸›¸¸˜¸ÿ¡–.“<<N—fª.’nÿ¡n?‘@Š@™‘@gªÿ{§k+#kkkkÿ™^­c¨”Sè•³ãµÀÿ™)Î™"ŠŠ=*ÿ±öÕ¥%Ÿ 
© Ÿ 
ÿ•†9ĞZ•44­•yÿ•C™ 0P ¤¤ ˜ÿ±öÕ¥…Ÿ 
© Ÿ 
ÿ|¢  ‹ š –  ¦ ÿr·=$¡õÉ‘ÿÁe³
ebœ
µ
œÿ‰{À8L½Ë´ı³¸¦ÿ‰L£
1]“ÒŒóMÿ‰(ÉYŒa—a™ÿ±öÕ¥…Ÿ 
© Ÿ 
ÿ±öÕ¥ÁŸ 
© Ÿ 
ÿµ"¯Ÿ*@¤*’@T˜7ÿ‰(n•Vœ**›*˜*˜.ÿ…^¯+¿¶sH¦ñ*¶)ÿ…;¤¡Ñ!µ§µ¿ÿ²Å‘ÅÅ¢ ÿÁD¦m’m‰-Œm©ÿìÁ	j“š“j‰ÿÁP›uÒˆuÒˆuÒˆuÒĞ ÿĞaœ<œVV’<Š<“*&ÿØg­ Õ ¢ *¬ ¢ *ÿĞ…¢f—@@…@”@–f;ÿºš¡”ÿ¸š ”ÿ¥§*B
 J³ *ÿĞàŸn›&H™ *ÿ}*¤¯õµÀ ˆjÿ}&¯î“š•š•š•š”š‘šÿvÔ¤¡¡‘¡Œ¡‘–ÿvÁeÍ
™
­
u/=ÿvœ*©³§ÂŸöÿvrc››#+BÿvDd,›ˆ¯ ÿuS]9y—®ƒ4ÂÿuEš£@Ğš‘šŒúŸš¾<ÿué¹ñ<«ÕŸÕ›Õÿm‡%Ißs}©»õ¼EÿmÉ¿ @hŠ  0ß *ÿĞéx §
f`­ › *ÿĞıŸ®°?®?ª?ÿi&ãb‹ãb¹‘I‹‘IÿÑ=ı*B
 JÃ *ÿiŸœ+ˆŠŠŠÿi «‹)¤qŒ-6‰-6ÿi¬-m¡<*–@.ÿiú#…Zsb­ › *ÿiôŸ ¢ £› *ÿeg‘ë6·€:şD¤ÿegM»€şD¤ÿe¹½9™I¬¡‹IÿÑ¥¹	šj‹j­	¬ÿea XÆ ² p£ pÿÕœnŒff¤nŒf“f nÿeM¾ó.®Ó.¦R•RÿaG…Syº…óŒïÿa¢•’’ššcÿ];üsĞ–SĞ¤5&—u ÿ]'Â ”¡’¡9–IÿÕŸÕ ¬Õ ˜ • œ • ÿYCe­–Y¢Á:³).ÿÕ^©©µ¸¸ ˆ­ÿY:ÃJ±©ô‘ÿY	I·q¬q¦µµ1ÿY
£˜+++K+ŠŠÿXê2™˜ ­ 8jP¢ *ÿUa¦Œ–°u¤ª˜rÿUŸ“•“í3›.ÿQ$UXUXŒİ¶»ÿQ
™ŸNŸf˜f£.nNÿQ
-¨
²
]£
ˆ
,ÿQÍ¾99›Q´9ÿQµ¹š¡ÿQ€Ş¦”¦¨Y¨¨¦”¦ÿQ5Ÿ ¥ ½ «  @ÿM­¢*@¤*’@T˜7ÿI'£Ÿjj˜šjj…ÿEy¤³{´}9
 ÿÙAª*¡@‘f’n.ˆ.ÿEO´‰Ÿ‰¨%Ã‰ˆRÿE	Õ€ş#á½›íÿE	²Å“Ÿ 
© Ÿ 
ÿE	²Å“Ÿ 
© Ÿ 
ÿE	•§jŒ‘áÿE	…¯‘ÍÄ)¤í˜íÿAÍœD€Îl4¬ÿÙy±w˜"POo$HÿAµ¬¹E”@?¥ ÿAIÇ<¥<< VËbÿ9˜	–‘‘“ÿ5á
#œKpˆ
-Jÿ5Q¨—•¦ÿ17£.<*‹@‹*‹<5Uÿ-88V4$7,$-® ª ÿ)fW2"jˆ"›˜R"ÿ%™;Œ;—ññs(ÿ!^Ã8L©\ÁÉ\¼j¦ÿÙ”n–ND{##¦ookÿ!Pı®  ˜ı¢ùmùmÿ!'¤õ³À ˆ­ÿ!eª œ p 3;3¨ÿ!™  ¬Í•ı¤ÿ!ŸnÂÃJŞ&û ÿ!¤²¯¬¦JRÿš~–~•~Œ~pH §  ÿ²Å“a­Ÿ 
© Ÿ 
ÿØ¨Ÿ 
© Ÿ 
ÿ¦Á’‹¢¢“¢ÿœnŒV®<’<*–@<ÿœnŒV<*–fŒ..ÿ›@ <•VL<œŸÿ€ÀÌ“µ¢ 
© Ÿ 
ÿ<› 0P(CKSB‡ ÿ¢¢—~ŒœŸ’’ÿ›—Y–Y—Yd
ÿ	C²…m–´–#=Œ…Ûÿ	C¦ñ•ñµ¨·ÿ
S;Kˆ ‡ h0ÿ¦Ÿ7<Ÿ7™4ÿF§n“n­n‘n•n¨nnÿ Í$ê„" 
Ø¥ÿÙMå³Ú¸+-ÊR†RÿÙ¸à¦àœ°Â°Sˆÿ Ë#4	Ò„" Ä¤ ÿ ›.}ÿ"Î†Î²ÿ ›,|ÿ.Èè­ÿ ›).stringValueAtIndex(index);
    const importInfo = this.getImportInfo(path);
    if (exportedName !== null) {
      importInfo.exportStarNames.push(exportedName);
    } else {
      importInfo.hasStarExport = true;
    }
  }

   getNamedImports(index) {
    const namedImports = [];
    while (true) {
      if (this.tokens.matches1AtIndex(index, tt.braceR)) {
        index++;
        break;
      }

      const specifierInfo = getImportExportSpecifierInfo(this.tokens, index);
      index = specifierInfo.endIndex;
      if (!specifierInfo.isType) {
        namedImports.push({
          importedName: specifierInfo.leftName,
          localName: specifierInfo.rightName,
        });
      }

      if (this.tokens.matches2AtIndex(index, tt.comma, tt.braceR)) {
        index += 2;
        break;
      } else if (this.tokens.matches1AtIndex(index, tt.braceR)) {
        index++;
        break;
      } else if (this.tokens.matches1AtIndex(index, tt.comma)) {
        index++;
      } else {
        throw new Error(`Unexpected token: ${JSON.stringify(this.tokens.tokens[index])}`);
      }
    }
    return {newIndex: index, namedImports};
  }

  /**
   * Get a mutable import info object for this path, creating one if it doesn't
   * exist yet.
   */
   getImportInfo(path) {
    const existingInfo = this.importInfoByPath.get(path);
    if (existingInfo) {
      return existingInfo;
    }
    const newInfo = {
      defaultNames: [],
      wildcardNames: [],
      namedImports: [],
      namedExports: [],
      hasBareImport: false,
      exportStarNames: [],
      hasStarExport: false,
    };
    this.importInfoByPath.set(path, newInfo);
    return newInfo;
  }

   addExportBinding(localName, exportedName) {
    if (!this.exportBindingsByLocalName.has(localName)) {
      this.exportBindingsByLocalName.set(localName, []);
    }
    this.exportBindingsByLocalName.get(localName).push(exportedName);
  }

  /**
   * Return the code to use for the import for this path, or the empty string if
   * the code has already been "claimed" by a previous import.
   */
  claimImportCode(importPath) {
    const result = this.importsToReplace.get(importPath);
    this.importsToReplace.set(importPath, "");
    return result || "";
  }

  getIdentifierReplacement(identifierName) {
    return this.identifierReplacements.get(identifierName) || null;
  }

  /**
   * Return a string like `exports.foo = exports.bar`.
   */
  resolveExportBinding(assignedName) {
    const exportedNames = this.exportBindingsByLocalName.get(assignedName);
    if (!exportedNames || exportedNames.length === 0) {
      return null;
    }
    return exportedNames.map((exportedName) => `exports.${exportedName}`).join(" = ");
  }

  /**
   * Return all imported/exported names where we might be interested in whether usages of those
   * names are shadowed.
   */
  getGlobalNames() {
    return new Set([
      ...this.identifierReplacements.keys(),
      ...this.exportBindingsByLocalName.keys(),
    ]);
  }
}
