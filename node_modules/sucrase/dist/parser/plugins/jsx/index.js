"use strict";Object.defineProperty(exports, "__esModule", {value: true});









var _index = require('../../tokenizer/index');
var _types = require('../../tokenizer/types');
var _base = require('../../traverser/base');
var _expression = require('../../traverser/expression');
var _util = require('../../traverser/util');
var _charcodes = require('../../util/charcodes');
var _identifier = require('../../util/identifier');
var _typescript = require('../typescript');

/**
 * Read token with JSX contents.
 *
 * In addition to detecting jsxTagStart and also regular tokens that might be
 * part of an expression, this code detects the start and end of text ranges
 * within JSX children. In order to properly count the number of children, we
 * distinguish jsxText from jsxEmptyText, which is a text range that simplifies
 * to the empty string after JSX whitespace trimming.
 *
 * It turns out that a JSX text range will simplify to the empty string if and
 * only if both of these conditions hold:
 * - The range consists entirely of whitespace characters (only counting space,
 *   tab, \r, and \n).
 * - The range has at least one newline.
 * This can be proven by analyzing any implementation of whitespace trimming,
 * e.g. formatJSXTextLiteral in Sucrase or cleanJSXElementLiteralChild in Babel.
 */
function jsxReadToken() {
  let sawNewline = false;
  let sawNonWhitespace = false;
  while (true) {
    if (_base.state.pos >= _base.input.length) {
      _util.unexpected.call(void 0, "Unterminated JSX contents");
      return;
    }

    const ch = _base.input.charCodeAt(_base.state.pos);
    if (ch === _charcodes.charCodes.lessThan || ch === _charcodes.charCodes.leftCurlyBrace) {
      if (_base.state.pos === _base.state.start) {
        if (ch === _charcodes.charCodes.lessThan) {
          _base.state.pos++;
          _index.finishToken.call(void 0, _types.TokenType.jsxTagStart);
          return;
        }
        _index.getTokenFromCode.call(void 0, ch);
        return;
      }
      if (sawNewline && !sawNonWhitespace) {
        _index.finishToken.call(void 0, _types.TokenType.jsxEmptyText);
      } else {
        _index.finishToken.call(void 0, _types.TokenType.jsxText);
      }
      return;
    }

    // This is part of JSX text.
    if (ch === _charcodes.charCodes.lineFeed) {
      sawNewline = true;
    } else if (ch !== _charcodes.charCodes.space && ch !== _charcodes.charCodes.carriageReturn && ch !== _charcodes.charCodes.tab) {
      sawNonWhitespace = true;
    }
    _base.state.pos++;
  }
}

function jsxReadString(quote) {
  _base.state.pos++;
  for (;;) {
    if (_base.state.pos >= _base.input.length) {
      _util.unexpected.call(void 0, "Unterminated string constant");
      return;
    }

    const ch = _base.input.charCodeAt(_base.state.pos);
    if (ch === quote) {
      _base.state.pos++;
      break;
    }
    _base.state.pos++;
  }
  _index.finishToken.call(void 0, _types.TokenType.string);
}

// Read a JSX identifier (valid tag or attribute name).
//
// Optimized version since JSX identifiers can't contain
// escape characters and so can be read as single slice.
// Also assumes that first character was already checked
// by isIdentifierStart in readToken.

function jsxReadWord() {
  let ch;
  do {
    if (_base.state.pos > _base.input.length) {
      _util.unexpected.call(void 0, "Unexpectedly reached the end of input.");
      return;
    }
    ch = _base.input.charCodeAt(++_base.state.pos);
  } while (_identifier.IS_IDENTIFIER_CHAR[ch] || ch === _charcodes.charCodes.dash);
  _index.finishToken.call(void 0, _types.TokenType.jsxName);
}

// Parse next token as JSX identifier
function jsxParseIdentifier() {
  nextJSXTagToken();
}

// Parse namespaced identifier.
function jsxParseNamespacedName(identifierRole) {
  jsxParseIdentifier();
  if (!_index.eat.call(void 0, _types.TokenType.colon)) {
    // Plain identifier, so this is an access.
    _base.state.tokens[_base.state.tokens.length - 1].identifierRole = identifierRole;
    return;
  }
  // Process the second half of the namespaced name.
  jsxParseIdentifier();
}

// Parses element name in any form - namespaced, member
// or single identifier.
function jsxParseElementName() {
  const firstTokenIndex = _base.state.tokens.length;
  jsxParseNamespacedName(_index.IdentifierRole.Access);
  let hadDot = false;
  while (_index.match.call(void 0, _types.TokenType.dot)) {
    hadDot = true;
    nextJSXTagToken();
    jsxParseIdentifier();
  }
  // For tags like <div> with a lowercase letter and no dots, the name is
  // actually *not* an identifier access, since it's referring to a built-in
  // tag name. Remove the identifier role in this case so that it's not
  // accidentally transformed by the imports transform when preserving JSX.
  if (!hadDot) {
    const firstToken = _base.state.tokens[firstTokenIndex];
    const firstChar = _base.input.charCodeAt(firstToken.start);
    if (firstChar >= _charcodes.charCodes.lowercaseA && firstChar <= _charcodes.charCodes.lowercaseZ) {
      firstToken.identifierRole = null;
    }
  }
}

// Parses any type of JSX attribute value.
function jsxParseAttributeValue() {
  switch (_base.state.type) {
    case _types.TokenType.braceL:
      _index.next.call(void 0, );
      _expression.parseExpression.call(void 0, );
      nextJSXTagToken();
      return;

    case _types.TokenType.jsxTagStart:
      jsxParseElement();
      nextJSXTagToken();
      return;

    case _types.TokenType.string:
      nextJSXTagToken();
      return;

    default:
      _util.unexpected.call(void 0, "JSX value should be either an expression or a quoted JSX text");
  }
}

// Parse JSX spread child, after already processing the {
// Does not parse the closing }
function jsxParseSpreadChild() {
  _util.expect.call(void 0, _types.TokenType.ellipsis);
  _expression.parseExpression.call(void 0, );
}

// Parses JSX opening tag starting after "<".
// Returns true if the tag was self-closing.
// Does not parse the last token.
function jsxParseOpeningElement(initialTokenIndex) {
  if (_index.match.call(void 0, _types.TokenType.jsxTagEnd)) {
    // This is an open-fragment.
    return false;
  }
  jsxParseElementName();
  if (_base.isTypeScriptEnabled) {
    _typescript.tsTryParseJSXTypeArgument.call(void 0, );
  }
  let hasSeenPropSpread = false;
  while (!_index.match.call(void 0, _types.TokenType.slash) && !_index.match.call(void 0, _types.TokenType.jsxTagEnd) && !_base.state.error) {
    if (_index.eat.call(void 0, _types.TokenType.braceL)) {
      hasSeenPropSpread = true;
      _util.expect.call(void 0, _types.TokenType.ellipsis);
      _expression.parseMaybeAssign.call(void 0, );
      // }
      nextJSXTagToken();
      continue;
    }
    if (
      hasSeenPropSpread &&
      _base.state.end - _base.state.start === 3 &&
      _base.input.charCodeAt(_base.state.start) === _charcodes.charCodes.lowercaseK &&
      _base.input.charCodeAt(_base.state.start + 1) === _charcodes.charCodes.lowercaseE &&
      _base.input.charCodeAt(_base.state.start + 2) === _charcodes.charCodes.lowercaseY
    ) {
      _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.KeyAfterPropSpread;
    }
    jsxParseNamespacedName(_index.IdentifierRole.ObjectKey);
    if (_index.match.call(void 0, _types.TokenType.eq)) {
      nextJSXTagToken();
      jsxParseAttributeValue();
    }
  }
  const isSelfClosing = _index.match.call(void 0, _types.TokenType.slash);
  if (isSelfClosing) {
    // /
    nextJSXTagToken();
  }
  return isSelfClosing;
}

// Parses JSX closing tag starting after "</".
// Does not parse the last token.
function jsxParseClosingElement() {
  if (_index.match.call(void 0, _types.TokenType.jsxTagEnd)) {
    // Fragment syntax, so we immediately have a tag end.
    return;
  }
  jsxParseElementName();
}

// Parses entire JSX element, including its opening tag
// (starting after "<"), attributes, contents and closing tag.
// Does not parse the last token.
function jsxParseElementAt() {
  const initialTokenIndex = _base.state.tokens.length - 1;
  _base.state.tokens[initialTokenIndex].jsxRole = _index.JSXRole.NoChildren;
  let numExplicitChildren = 0;
  const isSelfClosing = jsxParSVWAVAWHƒì M‹ùI‹ðL‹òHu{Nÿÿ‡%ÿH‹øH5|Nÿÿw%ÿH‹ØI‹Ïÿc%ÿI‹ÎHºæsH‹VL‹L‹H‹HÿVþë	L‹H‹HÿÖ3ÀHƒÄ A_A^_^[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌƒúsTHcÊH1½sÿHcˆHÈÿáëþH_‡ ë8H^‡ ë/H]‡ ë&H\‡ ëH;ÿÿÿëHR‡ ëHQ‡ ë3ÀÃÌÌÌÌSVWAVAWHƒì M‹ùI‹ðL‹òH•zNÿÿ§$ÿH‹øH|Nÿÿ—$ÿH‹ØI‹Ïÿƒ$ÿI‹ÎHºæsH‹VL‹L‹H‹HÿVþë	L‹H‹HÿÖ3ÀHƒÄ A_A^_^[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌƒúsTHcÊHq¼sÿHcˆHÈÿáëþH¯† ë8H®† ë/H­† ë&H¬† ëH;ÿÿÿëH¢† ëH¡† ë3ÀÃÌÌÌÌSVWAVAWHƒì M‹ùI‹ðL‹òH}|NÿÿÇ#ÿH‹øH¥~Nÿÿ·#ÿH‹ØI‹Ïÿ£#ÿI‹ÎHºæsH‹VD‹L‹H‹HÿVþë	D‹H‹HÿÖ3ÀHƒÄ A_A^_^[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌSVWAVHƒì(A‹øH‹òL‹ñº   H"†\ÿÿ,¯ÿH‹ØHHH‹Öÿ$¯ÿH~Nÿÿç®ÿ‰xHKH‹Ðÿ¯ÿI‹NH‹<rÿÿþ®ÿH‹HL‹H IºásI‹QL‹ÃH‹IÿQþëH‹ÓIÿÑHƒÄ(A^_^[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌƒúsKHcÊH»sÿHcˆHÈÿáëþH_… ë/H^… ë&H]… ëH\… ëH›þÿÿëHÿÿÿë3ÀÃÌÌÌÌÌÌÌÌÌÌÌÌÌSVWAVHƒì8H‹Ù‹A‰D$ HL$ ÿŠÿH‹ðH‹KÿÕÿ„ÀuH‹{ëH=ìÛ’ÿH‹ÝwKÿHƒÂðÿÓ­ÿH‹ÄwKÿL‹ðH‹€9 ‹Sèk“²ÿ…Ày	HèÛ’ÿëI‹€9 ‹Sèð™²ÿL‹Àƒ{ uHÜ’ÿL‹ÏH‹ÖëH)Ü’ÿL‹ÎH‹×ÿõÿHƒÄ8A^_^[ÃÌÌÌÌÌÌÌÌÌÌUHƒìPHl$0H‰M03À‰E H‰EH‰Eè ÿÿÿH‰EH‹EHe ]ÃSVWAVAWHƒì0L‹ùL‰}L‹u0I‹~H‹HÿP8H‹ðA€? I‹ÏÿA9ÿ‰E HM ÿ|ÿH‹ØI‹ÏH‹HÿPx€? H‹ÏÆD$(H‰D$ L‹ËL‹ÆHjÚ’ÿLÃŸÿAÿI‹Îÿÿ!ÿH‰EHpÿÿÿHƒÄ0A_A^_^[ÃSWHƒì(I‹ØH‹úI‹ÉÿË ÿH‹ÏHºãsH‹SH‹HÿSþëHÿÓŠØHNMÿÿj¬ÿˆXHƒÄ(_[ÃÌÌÌÌÌÌÌÌSWHƒì(H‹Ù3ÒH^ƒ\ÿÿh¬ÿH‹øH‹KH‹¢oÿÿd¬ÿH‹HL‹@ IºàsI‹PM‹HþL‹ÇH‹IÿÑëH‹×IÿÐH‹ÈH¢MMÿÿ,¬ÿŠ@HƒÄ(_[ÃÌÌƒúsKHcÊH‘¸sÿHcˆHÈÿáëþHß‚ ë/HÞ‚ ë&HÝ‚ ëHÜ‚ ëHûþÿÿëHBÿÿÿë3ÀÃÌÌÌÌÌÌÌÌÌÌÌÌÌSVWAVHìÈ   H‹ÚH‹ù3ÀH‰D$ H‰D$(H‰D$@H‰D$HH‰D$`H‹IHð2nÿÿ"¬ÿH‹ðD‹w3ÿLcÏL;NsSN‹LÎHT$ I‹IIÿQ HL$pHT$ A¸P   ÿh«ÿÿÇD;÷uÈA¸P   HT$pH‹Ëÿe«ÿH‹ÃHÄÈ   A^_^[Ãÿ¯bÿÌÌÌÌÌÌÌSHƒìp3ÀH‰D$ H‰D$(H‰D$@H‰D$HH‰D$`H‹ÚL‹AH‹AHL$ HºàsH‹PH‹HÿPþëI‹ÐHÿÐA¸P   HT$ H‹ËÿêªÿH‹ÃHƒÄp[ÃÌÌÌÌÌÌÌÌÌSHƒìp3ÀH‰D$ H‰D$(H‰D$@H‰D$HH‰D$`H‹ÚH‹AHL$ HºàsH‹PH‹HÿPþëHÿÐA¸P   HT$ H‹ËÿªÿH‹ÃHƒÄp[ÃSHƒìp3ÀH‰D$ H‰D$(H‰D$@H‰D$HH‰D$`H‹ÚL‹IH‹AHT$ I‹ÉHºàsL‹@M‹ HÿPþëHÿÐA¸P   HT$ H‹ËÿªÿH‹ÃHƒÄp[ÃÌÌÌÌÌÌÌÌÌSWHƒìx3ÀH‰D$ H‰D$(H‰D$@H‰D$HH‰D$`I‹ØH‹úI‹Éÿ ÿHT$ H‹ÏHºãsL‹CM‹ HÿSþëHÿÓHJÖLÿÿ<©ÿH‹ØHHA¸P   HT$ ÿ”©ÿH‹ÃHƒÄx_[ÃÌÌSVWHƒìpH‹òH‹Ù3À3ÒH€\ÿÿ"©ÿH‹øH‹KH‹\lÿÿ©ÿH‹HL‹@ IºàsI‹PM‹HþL‹ÇH‹IÿÑëH‹×IÿÐH‹ÈH¼ÕLÿÿæ¨ÿHPHL$ »P   D‹Ãÿï¨ÿD‹ÃHT$ H‹Îÿö¨ÿH‹ÆHƒÄp_^[ÃÌÌÌƒúsKHcÊHAµsÿHcˆHÈÿáëþHÏüÿÿë/Hvýÿÿë&HÝýÿÿëH4þÿÿëH›þÿÿëHÿÿÿë3ÀÃÌÌÌÌÌÌÌÌÌÌÌÌÌSVWHƒì H‹ÙH‹IH£/nÿÿÕ¨ÿH‹ø‹s3ÛHcÓH;WsH‹T×L‹B H‹JIÿÐÿÃ;óuáHƒÄ _^[Ãÿ˜_ÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌHƒì(H‹QL‹AIºàsI‹@M‹@þH‹IÿÐëH‹ÊIÿÐHƒÄ(ÃÌHƒì(H‹IHºásH‹AH‹QþH‹HÿÒëHÿÑHƒÄ(ÃÌÌÌÌÌÌÌÌHƒì(L‹IH‹QI‹ÉHºâsH‹BL‹BþH‹IÿÐëHÿÒHƒÄ(ÃÌSWHƒì(I‹ØH‹úI‹ÉÿKÿH‹ÏHºãsH‹CL‹CþH‹IÿÐëHÿÓ‹ØH‹¥uÿÿç¦ÿ‰XHƒÄ(_[ÃÌÌÌÌÌSWHƒì(H‹Ù3ÒHÞ}\ÿÿè¦ÿH‹øH‹KH‹"jÿÿä¦ÿH‹HL‹@ IºàsI‹PM‹HþL‹ÇH‹IÿÑëH‹×IÿÐH‹ØH‹È²	ÿŽ¦ÿ‹CHƒÄ(_[ÃÌÌÌÌƒúsKHcÊHQ³sÿHcˆHÈÿáëþH/þÿÿë/H†þÿÿë&H­þÿÿëHÔþÿÿëHûþÿÿëHBÿÿÿë3ÀÃÌÌÌÌÌÌÌÌÌÌÌÌÌSHƒì03ÀH‰D$ H‹ÚH‰T$ H‹T$ L‹IH‹A I‹ÉHºàsL‹@M‹ HÿPþëHÿÐH‹ÃHƒÄ0[ÃÌÌÌÌÌÌÌÌÌÌÌÌSVWAVAWHƒì@H‹ÚH‹ùH‰T$ H‹t$ 3ÀH‰H‰FH‹IH)-nÿÿ[¦ÿL‹ðD‹3ÿLcÇM;Fs1O‹DÆHT$(I‹HIÿP D$(óÿÇD;ÿuÕH‹ÃHƒÄ@A_A^_^[Ãÿ
]ÿÌÌSHƒì03ÀH‰D$ H‹ÚH‰T$ L‹L$ L‹AH‹AI‹ÉHºàsH‹PH‹HÿPþëI‹ÐHÿÐH‹ÃHƒÄ0[ÃÌÌÌÌÌÌÌÌÌSHƒì03ÀH‰D$ H‹ÚH‹ÁH‰T$ H‹L$ H‹@HºàsH‹PH‹HÿPþëHÿÐH‹ÃHƒÄ0[ÃSHƒì03ÀH‰D$ H‹ÚH‰T$ H‹T$ L‹IH‹AI‹ÉHºàsL‹@M‹ HÿPþëHÿÐH‹ÃHƒÄ0[ÃÌÌÌÌÌÌÌÌÌÌÌÌSWHƒì8I‹ØH‹úI‹Éÿ{ÿHT$ H‹ÏHºãsL‹CM‹ HÿSþëHÿÓHÐWÿÿ¤ÿD$ ó@HƒÄ8_[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌSVWAVHƒì8H‹ÚH‹ñH‰T$ H‹|$ 3ÒHîz\ÿÿø£ÿL‹ðH‹NH‹2gÿÿô£ÿH‹HL‹@ IºàsI‹PM‹HþM‹ÆH‹IÿÑëI‹ÖIÿÐH‹ÈHzÏWÿÿ¼£ÿ@óH‹ÃHƒÄ8A^_^[ÃÌÌÌÌÌÌÌƒúsKHcÊHq°sÿHcˆHÈÿáëþHýÿÿë/Hþÿÿë&HMþÿÿëH„þÿÿëHËþÿÿëH"ÿÿÿë3ÀÃÌÌÌÌÌÌÌÌÌÌÌÌÌSVWAVAWHƒìpM‹ðH‹ÚH‹ù3ÀH‰D$@H‹IH‚*nÿÿ´£ÿH‹ðD‹3ÿLcÏL;NsrN‹LÎI‹H‰D$ I‹FH‰D$(I‹FH‰D$0LD$ HT$@I‹IIÿQ H‹D$HH‰D$`H‹D$PH‰D$hÿÇD;ÿu«H‹ËH‹T$@ÿÀ¢ÿD$`CH‹ÃHƒÄpA_A^_^[Ãÿ"ZÿÌÌÌÌÌÌÌÌÌÌSHì€   3ÀH‰D$`H‹ÚL‹YL‹QI‹ HL$`Iºâs,H‰D$ I‹@H‰D$(I‹@H‰D$0I‹RLL$ M‹ÃH‹IÿRþë"H‰D$@I‹@H‰D$HI‹@H‰D$PLD$@I‹ÓIÿÒH‹ËH‹T$`ÿ¢ÿD$hCH‹ÃHÄ€   [ÃÌÌÌÌÌÌSHì€   3ÀH‰D$`H‹ÚL‹II‹ HL$`Iºás)H‰D$ I‹@H‰D$(I‹@H‰D$0I‹QLD$ H‹IÿQþëH‰D$@I‹@H‰D$HI‹@H‰D$PHT$@IÿÑH‹ËH‹T$`ÿ}¡ÿD$hCH‹ÃHÄ€   [ÃSHì€   3ÀH‰D$`H‹ÚL‹YL‹QI‹ H