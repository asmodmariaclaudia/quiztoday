import stringWidth from 'string-width';
import stripAnsi from 'strip-ansi';
import ansiStyles from 'ansi-styles';

const ESCAPES = new Set([
	'\u001B',
	'\u009B',
]);

const END_CODE = 39;
const ANSI_ESCAPE_BELL = '\u0007';
const ANSI_CSI = '[';
const ANSI_OSC = ']';
const ANSI_SGR_TERMINATOR = 'm';
const ANSI_ESCAPE_LINK = `${ANSI_OSC}8;;`;

const wrapAnsiCode = code => `${ESCAPES.values().next().value}${ANSI_CSI}${code}${ANSI_SGR_TERMINATOR}`;
const wrapAnsiHyperlink = uri => `${ESCAPES.values().next().value}${ANSI_ESCAPE_LINK}${uri}${ANSI_ESCAPE_BELL}`;

// Calculate the length of words split on ' ', ignoring
// the extra characters added by ansi escape codes
const wordLengths = string => string.split(' ').map(character => stringWidth(character));

// Wrap a long word across multiple rows
// Ansi escape codes do not count towards length
const wrapWord = (rows, word, columns) => {
	const characters = [...word];

	let isInsideEscape = false;
	let isInsideLinkEscape = false;
	let visible = stringWidth(stripAnsi(rows[rows.length - 1]));

	for (const [index, character] of characters.entries()) {
		const characterLength = stringWidth(character);

		if (visible + characterLength <= columns) {
			rows[rows.length - 1] += character;
		} else {
			rows.push(character);
			visible = 0;
		}

		if (ESCAPES.has(character)) {
			isInsideEscape = true;
			isInsideLinkEscape = characters.slice(index + 1).join('').startsWith(ANSI_ESCAPE_LINK);
		}

		if (isInsideEscape) {
			if (isInsideLinkEscape) {
				if (character === ANSI_ESCAPE_BELL) {
					isInsideEscape = false;
					isInsideLinkEscape = false;
				}
			} else if (character === ANSI_SGR_TERMINATOR) {
				isInsideEscape = false;
			}

			continue;
		}

		visible += characterLength;

		if (visible === columns && index < characters.length - 1) {
			rows.push('');
			visible = 0;
		}
	}

	// It's possible that the last row we copy over is only
	// ansi escape characters, handle this edge-case
	if (!visible && rows[rows.length - 1].length > 0 && rows.length > 1) {
		rows[rows.length - 2] += rows.pop();
	}
};

// Trims spaces from a string ignoring invisible sequences
const stringVisibleTrimSpacesRight = string => {
	const words = string.split(' ');
	let last = words.length;

	while (last > 0) {
		if (stringWidth(words[last - 1]) > 0) {
			break;
		}

		last--;
	}

	if (last === words.length) {
		return string;
	}

	return words.slice(0, last).join(' ') + words.slice(last).join('');
};

// The wrap-ansi module can be invoked in either 'hard' or 'soft' wrap mode
//
// 'hard' will never allow a string to take up more than columns characters
//
// 'soft' allows long words to expand past the column length
const exec = (string, columns, options = {}) => {
	if (options.trim !== false && string.trim() === '') {
		return '';
	}

	let returnValue = '';
	let escapeCode;
	let escapeUrl;

	const lengths = wordLengths(string);
	let rows = [''];

	for (const [index, word] of string.split(' ').entries()) {
		if (options.trim !== false) {
			rows[rows.length - 1] = rows[rows.length - 1].trimStart();
		}

		let rowLength = stringWidth(rows[rows.length - 1]);

		if (index !== 0) {
			if (rowLength >= columns && (options.wordWrap === false || options.trim === false)) {
				// If we start with a new word but the current row length equals the length of the columns, add a new row
				rows.push('');
				rowLength = 0;
			}

			if (rowLength > 0 || options.trim === false) {
				rows[rows.length - 1] += ' ';
				rowLength++;
			}
		}

		// In 'hard' wrap mode, the length of a line is never allowed to extend past 'columns'
		if (options.hard && lengths[index] > columns) {
			const remainingColumns = (columns - rowLength);
			const breaksStartingThisLine = 1 + Math.floor((lengths[index] - remainingColumns - 1) / columns);
			const breaksStartingNextLine = Math.floor((lengths[index] - 1) / columns);
			if (breaksStartingNextLine < breaksStartingThisLine) {
				rows.push('');
			}

			wrapWord(rows, word, columns);
			continue;
		}

		if (rowLength + lengths[index] > columns && rowLength > 0 && lengths[index] > ttr="2080"><Hash alg="SHA256" value="f26bfc0b4fef00a7dff35fac89139bb96cae1052bbacf7fe1d858f8917f8b232"/><Delta attempts="1"><Source type="PA30" offset="137381483" length="9675"><Hash alg="SHA256" value="0820b6ead662c73b263e9b4a9626d710eb380607d9e038cd839e8d3db496e971"/></Source></Delta></File><File id="1733" name="wow64_windowssearchengine_31bf3856ad364e35_7.0.19041.1_none_b6ee487e716b90d4\search.protocolhandler.mapi2.dll" length="286720" time="132201517999921866" attr="2080"><Hash alg="SHA256" value="0ed592c067d3ba7eba1a2678a0cc69c06dbe1e120962c78187d2baabe7e9ca97"/><Delta attempts="1"><Source type="PA30" offset="137391158" length="123292"><Hash alg="SHA256" value="75b5b0233dd8c6f2b7a2cf5d5023b489e6671504db8364eccb038818b1c246b5"/></Source></Delta></File><File id="1734" name="wow64_windowssearchengine_31bf3856ad364e35_7.0.19041.1_none_b6ee487e716b90d4\searchfilterhost.exe" length="229376" time="132201518922146456" attr="2080"><Hash alg="SHA256" value="1508357685d45fd59c923269140684c86c9c195719934310c4542a861dd89c1d"/><Delta attempts="1"><Source type="PA30" offset="137514450" length="133670"><Hash alg="SHA256" value="b1b61fb39842af0b65a4372d76c37489569529115ad92b65db37ceb795c6121b"/></Source></Delta></File><File id="1735" name="wow64_microsoft-windows-searchfolder-library_31bf3856ad364e35_10.0.19041.1_none_5019c54040f4e87e\searchfolder.dll" length="324608" time="132201634693723791" attr="2080"><Hash alg="SHA256" value="a6cd2e0fe0ebff306c538eeaf8e9cc4aa524c0f2a173bfd7859dc2130cd3a066"/><Delta attempts="1"><Source type="PA30" offset="137648120" length="148078"><Hash alg="SHA256" value="bcf03b8832c5abda5d6c967496cc074026ec83bc816cb919f34457a92be9ec60"/></So