/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
/// <reference types="node" />
import { EventEmitter } from 'events';
import { StringDecoder } from 'string_decoder';
/**
 * Same as StringDecoder, but exposing the `lastNeed` flag on the type
 */
type SD = StringDecoder & {
    lastNeed: boolean;
};
export type { SD, Pipe, PipeProxyErrors };
/**
 * Return true if the argument is a Minipass stream, Node stream, or something
 * else that Minipass can interact with.
 */
export declare const isStream: (s: any) => s is NodeJS.WriteStream | NodeJS.ReadStream | Minipass<any, any, any> | (NodeJS.ReadStream & {
    fd: number;
}) | (EventEmitter & {
    pause(): any;
    resume(): any;
    pipe(...destArgs: any[]): any;
}) | (NodeJS.WriteStream & {
    fd: number;
}) | (EventEmitter & {
    end(): any;
    write(chunk: any, ...args: any[]): any;
});
/**
 * Return true if the argument is a valid {@link Minipass.Readable}
 */
export declare const isReadable: (s: any) => s is Minipass.Readable;
/**
 * Return true if the argument is a valid {@link Minipass.Writable}
 */
export declare const isWritable: (s: any) => s is Minipass.Readable;
declare const EOF: unique symbol;
declare const MAYBE_EMIT_END: unique symbol;
declare const EMITTED_END: unique symbol;
declare const EMITTING_END: unique symbol;
declare const EMITTED_ERROR: unique symbol;
declare const CLOSED: unique symbol;
declare const READ: unique symbol;
declare const FLUSH: unique symbol;
declare const FLUSHCHUNK: unique symbol;
declare const ENCODING: unique symbol;
declare const DECODER: unique symbol;
declare const FLOWING: unique symbol;
declare const PAUSED: unique symbol;
declare const RESUME: unique symbol;
declare const BUFFER: unique symbol;
declare const PIPES: unique symbol;
declare const BUFFERLENGTH: unique symbol;
declare const BUFFERPUSH: unique symbol;
declare const BUFFERSHIFT: unique symbol;
declare const OBJECTMODE: unique symbol;
declare const DESTROYED: unique symbol;
declare const ERROR: unique symbol;
declare const EMITDATA: unique symbol;
declare const EMITEND: unique symbol;
declare const EMITEND2: unique symbol;
declare const ASYNC: unique symbol;
declare const ABORT: unique symbol;
declare const ABORTED: unique symbol;
declare const SIGNAL: unique symbol;
declare const DATALISTENERS: unique symbol;
declare const DISCARDED: unique symbol;
/**
 * Options that may be passed to stream.pipe()
 */
export interface PipeOptions {
    /**
     * end the destination stream when the source stream ends
     */
    end?: boolean;
    /**
     * proxy errors from the source stream to the destination stream
     */
    proxyErrors?: boolean;
}
/**
 * Internal class representing a pipe to a destination stream.
 *
 * @internal
 */
declare class Pipe<T extends unknown> {
    src: Minipass<T>;
    dest: Minipass<any, T>;
    opts: PipeOptions;
    ondrain: () => any;
    constructor(src: Minipass<T>, dest: Minipass.Writable, opts: PipeOptions);
    unpipe(): void;
    proxyErrors(_er: any): void;
    end(): void;
}
/**
 * Internal class representing a pipe to a destination stream where
 * errors are proxied.
 *
 * @internal
 */
declare class PipeProxyErrors<T> extends Pipe<T> {
    unpipe(): void;
    constructor(src: Minipass<T>, dest: Minipass.Writable, opts: PipeOptions);
}
export declare namespace Minipass {
    /**
     * Encoding used to create a stream that outputs strings rather than
     * Buffer objects.
     */
    export type Encoding = BufferEncoding | 'buffer' | null;
    /**
     * Any stream that Minipass can pipe into
     */
    export type Writable = Minipass<any, any, any> | NodeJS.WriteStream | (NodeJS.WriteStream & {
        fd: number;
    }) | (EventEmitter & {
        end(): any;
        write(chunk: any, ...args: any[]): any;
    });
    /**
     * Any stream that can be read from
     */
    export type Readable = Minipass<any, any, any> | NodeJS.ReadStream | (NodeJS.ReadStream & {
        fd: number;
    }) | (EventEmitter & {
        pause(): any;
        resume(): any;
        pipe(...destArgs: any[]): any;
    });
    /**
     * Utility type that can be iterated sync or async
     */
    export type DualIterable<T> = Iterable<T> & AsyncIterable<T>;
    type EventArguments = Record<string | symbol, unknown[]>;
    /**
     * The listing of events that a Minipass class can emit.
     * Extend this when extending the Minipass class, and pass as
     * the third template argument.  The key is the name of the event,
     * and the value is the argument list.
     *
     * Any undeclared events will still be allowed, but the handler will get
     * arguments as `unknown[]`.
     */
    export interface Events<RType extends any = Buffer> extends EventArguments {
        readable: [];
        data: [chunk: RType];
        error: [er: unknown];
        abort: [reason: unknown];
        drain: [];
        resume: [];
        end: [];
        finish: [];
        prefinish: [];
        close: [];
        [DESTROYED]: [er?: unknown];
        [ERROR]: [er: unknown];
    }
    /**
     * String or buffer-like data that can be joined and sliced
     */
    export type ContiguousData = Buffer | ArrayBufferLike | ArrayBufferView | string;
    export type BufferOrString = Buffer | string;
    /**
     * Options passed to the Minipass constructor.
     */
    export type SharedOptions = {
        /**
         * Defer all data emission and other events until the end of the
         * current tick, similar to Node core streams
         */
        async?: boolean;
        /**
         * A signal which will abort the stream
         */
        signal?: AbortSignal;
        /**
         * Output string encoding. Set to `null` or `'buffer'` (or omit) to
         * emit Buffer objects rather than strings.
         *
         * Conflicts with `objectMode`
         */
        encoding?: BufferEncoding | null | 'buffer';
        /**
         * Output data exactly as it was written, supporting non-buffer/string
         * data (such as arbitrary objects, falsey values, etc.)
         *
         * Conflicts with `encoding`
         */
        objectMode?: boolean;
    };
    /**
     * Options for a string encoded output
     */
    export type EncodingOptions = SharedOptions & {
        encoding: BufferEncoding;
        objectMode?: false;
    };
    /**
     * Options for contiguous data buffer output
     */
    export type BufferOptions = SharedOptions & {
        encoding?: null | 'buffer';
        objectMode?: false;
    };
    /**
     * Options for objectMode arbitrary output
     */
    export type ObjectModeOptions = SharedOptions & {
        objectMode: true;
        encoding?: null;
    };
    /**
     * Utility type to determine allowed options based on read type
     */
    export type Options<T> = T extends string ? EncodingOptions | ObjectModeOptions : T extends Buffer ? BufferOptions | ObjectModeOptions : SharedOptions;
    export {};
}
/**
 * Main export, the Minipass class
 *
 * `RType` is the type of data emitted, defaults to Buffer
 *
 * `WType` is the type of data to be written, if RType is buffer or string,
 * then any {@link Minipass.ContiguousData} is allowed.
 *
 * `Events` is the set of event handler signatures that this object
 * will emit, see {@link Minipass.Events}
 */
export declare class Minipass<RType extends unknown = Buffer, WType extends unknown = RType extends Minipass.BufferOrString ? Minipass.ContiguousData : RType, Events extends Minipass.Events<RType> = Minipass.Events<RType>> extends EventEmitter implements Minipass.DualIterable<RType> {
    [FLOWING]: boolean;
    [PAUSED]: boolean;
    [PIPES]: Pipe<RType>[];
    [BUFFER]: RType[];
    [OBJECTMODE]: boolean;
    [ENCODING]: BufferEncoding | null;
    [ASYNC]: boolean;
    [DECODER]: SD | null;
    [EOF]: boolean;
    [EMITTED_END]: boolean;
    [EMITTING_END]: boolean;
    [CLOSED]: boolean;
    [EMITTED_ERROR]: unknown;
    [BUFFERLENGTH]: number;
    [DESTROYED]: boolean;
    [SIGNAL]?: AbortSignal;
    [ABORTED]: boolean;
    [DATALISTENERS]: number;
    [DISCARDED]: boolean;
    /**
     * true if the stream can be written
     */
    writable: boolean;
    /**
     * true if the stream can be read
     */
    readable: boolean;
    /**
     * If `RType` is Buffer, then options do not need to be provided.
     * Otherwise, an options object must be provided to specify either
     * {@link Minipass.SharedOptions.objectMode} or
     * {@link Minipass.SharedOptions.encoding}, as appropriate.
     */
    constructor(...args: RType extends Buffer ? [] | [Minipass.Options<RType>] : [Minipass.Options<RType>]);
    /**
     * The amount of data stored in the buffer waiting to be read.
     *
     * For Buffer strings, this will be the total byte length.
     * For string encoding streams, this will be the string character length,
     * according to JavaScript's `string.length` logic.
     * For objectMode streams, this is a count of the items waiting to be
     * emitted.
     */
    get bufferLength(): number;
    /**
     * The `BufferEncoding` currently in use, or `null`
     */
    get encoding(): BufferEncoding | null;
    /**
     * @deprecated - This is a read only property
     */
    set encoding(_enc: BufferEncoding | null);
    /**
     * @deprecated - Encoding may only be set at instantiation time
     */
    setEncoding(_enc: Minipass.Encoding): void;
    /**
     * True if this is an objectMode stream
     */
    get objectMode(): boolean;
    /**
     * @deprecated - This is a read-only property
     */
    set objectMode(_om: boolean);
    /**
     * true if this is an async stream
     */
    get ['async'](): boolean;
    /**
     * Set to true to make this stream async.
     *
     * Once set, it cannot be unset, as this would potentially cause incorrect
     * behavior.  Ie, a sync stream can be made async, but an async stream
     * cannot be safely made sync.
     */
    set ['async'](a: boolean);
    [ABORT](): void;
    /**
     * True if the stream has been aborted.
     */
    get aborted(): boolean;
    /**
     * No-op setter. Stream aborted status is set via the AbortSignal provided
     * in the constructor options.
     */
    set aborted(_: boolean);
    /**
     * Write data into the stream
     *
     * If the chunk written is a string, and encoding is not specified, then
     * `utf8` will be assumed. If the stream encoding matches the encoding of
     * a written string, and the state of the string decoder allows it, then
     * the string will be passed through to either the output or the internal
     * buffer without any processing. Otherwise, it will be turned into a
     * Buffer object for processing into the desired encoding.
     *
     * If provided, `cb` function is called immediately before return for
     * sync streams, or on next tick for async streams, because for this
     * base class, a chunk is considered "processed" once it is accepted
     * and either emitted or buffered. That is, the callback does not indicate
     * that the chunk has been eventually emitted, though of course child
     * classes can override this function to do whatever processing is required
     * and call `super.write(...)` only once processing is completed.
     */
    write(chunk: WType, cb?: () => void): boolean;
    write(chunk: WType, encoding?: Minipass.Encoding, cb?: () => void): boolean;
    /**
     * Low-level explicit read method.
     *
     * In objectMode, the argument is ignored, and one item is returned if
     * available.
     *
     * `n` is the number of bytes (or in the case of encoding streams,
     * characters) to consume. If `n` is not provided, then the entire buffer
     * is returned, or `null` is returned if no data is available.
     *
     * If `n` is greater that the amount of data in the internal buffer,
     * then `null` is returned.
     */
    read(n?: number | null): RType | null;
    [READ](n: number | null, chunk: RType): RType;
    /**
     * End the stream, optionally providing a final write.
     *
     * See {@link Minipass#write} for argument descriptions
     */
    end(cb?: () => void): this;
    end(chunk: WType, cb?: () => void): this;
    end(chunk: WType, encoding?: Minipass.Encoding, cbÌH‹SöÂtH‹Rÿÿd2ÜÿH…ÀuH‹Çë"H‹L$@H‹SöÂtH‹RÿÿB2ÜÿH‹ÈH‹HÿP IN8H‹ĞÿK1Üÿ‹ƒ   L‹à‹ƒ˜   HM‹ÄH‹´$ˆ   H‹Îÿô1ÜÿM‹Ä3ÒI‹Ïÿö0ÜÿI‹ÏH‹öÂtH‹Rÿÿá1ÜÿH…Àu,M‹ÄH‹ÖI‹Ïÿ½1ÜÿI‹÷I‹ÏH‹öÂtH‹Rÿÿµ1ÜÿH…Àt"H‹ÎH‹öÂtH‹Rÿÿ›1ÜÿH‹ÈH‹HÿP H‹øIN@H‹×ÿ¡0ÜÿM‹ÆHßcŞÿ3Éÿ÷›ÛÿHÄ    A_A^A]A\_^[ÃÌÌÌSVWATAUAVAWHƒìpL‹ñH‰L$hH‹L$hH‹	Hp%ÊÿèÍÜK H‹ğH‹öÁtH‹Iÿÿ 1ÜÿHƒÀH‰D$`H‹NöÁtH‹Iÿÿä0ÜÿHƒÀH‰D$XH‹NöÁtH‹IÿÿÈ0ÜÿHƒÀH‰D$PH‹NöÁtH‹Iÿÿ¬0ÜÿHƒÀH‰D$HH‹N öÁtH‹Iÿÿ0ÜÿHƒÀH‰D$@H‹N(öÁtH‹Iÿÿt0ÜÿHƒÀL‹èH‹N0öÁtH‹IÿÿZ0ÜÿHƒÀL‹àH‹    öÁtH‹Iÿÿ5åÛÿH‹øH‰D$8‹†¨   H‹H‹L‹øH‹Øƒã‹F8L‹ÀIVI‹Ìÿ0ÜÿH…Ût"I‹GH‹H‹¾°   M‹OşM‹ÄH‹ÓH‹L$8Hÿ×ëH‹¸   M‹ÇI‹ÔH‹ÏHÿÓiÀ×ªªZ¹»ŒŞ+È‰L$ H‹À   öÁtH‹Iÿÿ£äÛÿL‹à‹F@H‹Ø‹†È   I‹$H‹L‹øH‹øƒçA€> I‹FHL‹ÀI‹Íÿ|/ÜÿH…ÿt I‹GH‹H‹¾Ğ   M‹OşM‹ÅH‹ÓI‹ÌHÿ×ëH‹Ø   M‹ÇI‹ÕI‹ÌHÿÓD$ iÀ)UU¥‰D$$H‹à   öÁtH‹IÿÿäÛÿL‹à‹†è   I‹$H‹L‹øH‹Øƒã‹FPL‹À‹FXIL‹l$@I‹Íÿë.ÜÿH…Ût I‹GH‹H‹¾ğ   M‹OşM‹ÅH‹ÓI‹ÌHÿ×ëH‹ø   M‹ÇI‹ÕI‹ÌHÿÓD$$iÀ)UU¥‰D$(H‹   öÁtH‹IÿÿãÛÿL‹à‹†  I‹$H‹L‹øH‹Øƒã‹F`L‹À‹FhIL‹l$HI‹ÍÿZ.ÜÿH…Ût I‹GH‹H‹¾  M‹OşM‹ÅH‹ÓI‹ÌHÿ×ëH‹  M‹ÇI‹ÕI‹ÌHÿÓD$(iÀ)UU¥‰D$,H‹   öÁtH‹IÿÿîâÛÿL‹à‹†(  I‹$H‹L‹øH‹Øƒã‹FpL‹À‹FxIL‹l$PI‹ÍÿÉ-ÜÿH…Ût I‹GH‹H‹¾0  M‹OşM‹ÅH‹ÓI‹ÌHÿ×ëH‹8  M‹ÇI‹ÕI‹ÌHÿÓD$,iÀ)UU¥‰D$0H‹@  öÁtH‹Iÿÿ]âÛÿL‹à‹†H  I‹$H‹L‹øH‹Øƒã‹†€   L‹À‹†ˆ   IL‹l$XI‹Íÿ2-ÜÿH…Ût I‹GH‹H‹¾P  M‹OşM‹ÅH‹ÓI‹ÌHÿ×ëH‹X  M‹ÇI‹ÕI‹ÌHÿÓD$0Diè)UU¥H‹`  öÁtH‹IÿÿÉáÛÿL‹à‹†h  I‹$H‹L‹øH‹Øƒã‹†   L‹À‹†˜   IL‹t$`I‹Îÿ,ÜÿH…Ût I‹GH‹H‹¾p  M‹OşM‹ÆH‹ÓI‹ÌHÿ×ëH‹x  M‹ÇI‹ÖI‹ÌHÿÓAÅHƒÄpA_A^A]A\_^[ÃÌÌÌÌÌÌÌÌÌÌÌSVWATAUAVAWHìĞ   H‹ÚL‹ùH‰Œ$À   H‹Œ$À   H‹	Hd ÊÿèÁ×K L‹ğI‹öÁtH‹Iÿÿô+ÜÿHƒÀH‰„$¸   I‹öÁtH‹IÿÿÖ+ÜÿHƒÀH‰D$pI‹NöÁtH‹Iÿÿº+ÜÿHƒÀH‰„$¨   I‹NöÁtH‹Iÿÿ›+ÜÿHƒÀH‰D$`I‹NöÁtH‹Iÿÿ+ÜÿHƒÀH‰„$    I‹NöÁtH‹Iÿÿ`+ÜÿHƒÀH‰D$XI‹NöÁtH‹IÿÿD+ÜÿHƒÀH‰„$°   I‹NöÁtH‹Iÿÿ%+ÜÿHƒÀH‰D$PI‹N öÁtH‹Iÿÿ	+ÜÿHƒÀH‰„$ˆ   I‹N öÁtH‹Iÿÿê*ÜÿHƒÀH‰D$HI‹N(öÁtH‹IÿÿÎ*ÜÿHƒÀH‰D$xI‹N(öÁtH‹Iÿÿ²*ÜÿHƒÀH‰D$@I‹N0öÁtH‹Iÿÿ–*ÜÿHƒÀH‰D$8I‹N0öÁtH‹Iÿÿz*ÜÿHƒÀH‰D$0H‹ËI‹–€  öÂtH‹Rÿÿ*ÜÿL‹àH‰D$hH…À„Q  I‹    öÁtH‹Iÿÿ)ßÛÿL‹èA‹†ˆ  I‹M H‹H‹ğH‹øƒçA‹F8H‹ØIT$L‹ÀH‹L$0ÿ*ÜÿIWL‹ÃH‹L$8ÿò)ÜÿH…ÿt,H‹^şH‹FH‹8I‹¶  H‰\$ L‹L$0L‹D$8H‹×I‹ÍHÿÖëI‹˜  L‹ÎL‹D$0H‹T$8I‹ÍHÿÓ„À„¡  I‹À   öÁtH‹IÿÿyŞÛÿH‹ÈH‰„$€   A‹F@H‹øA‹†   H‹	H‹L‹èH‹ğƒæA‹FHH‹ØJ'L‹ÀH‹L$@ÿG)ÜÿA€? I?L‹ÃH‹|$xH‹Ïÿ.)ÜÿH…öt1I‹]şI‹EH‹8I‹¶¨  H‰\$ L‹L$@L‹D$xH‹×H‹Œ$€   HÿÖëI‹°  M‹ÍL‹D$@H‹×H‹Œ$€   HÿÓ„À„Õ  I‹à   öÁtH‹Iÿÿ­İÛÿH‰„$   A‹¸  H‹ H‹L‹èH‹ğƒæA‹FPH‹øA‹FXH‹ØJ L‹ÇH‹L$Hÿ~(ÜÿJ;L‹ÇH‹¼$ˆ   H‹Ïÿf(ÜÿH…öt4I‹]şI‹EH‹8I‹¶À  H‰\$ L‹L$HL‹„$ˆ   H‹×H‹Œ$   HÿÖëI‹È  M‹ÍL‹D$HH‹×H‹Œ$   HÿÓ„À„
  I‹   öÁtH‹IÿÿâÜÛÿH‰„$˜   A‹Ğ  H‹ H‹L‹èH‹ğƒæA‹F`H‹øA‹FhH‹ØJ L‹ÇH‹L$Pÿ³'ÜÿJ;L‹ÇL‹¤$°   I‹Ìÿ›'ÜÿH…öt/I‹]şI‹EH‹8I‹¶Ø  H‰\$ L‹L$PM‹ÄH‹×H‹Œ$˜   HÿÖëI‹à  M‹ÍL‹D$PI‹ÔH‹Œ$˜   HÿÓ„À„D  I‹   öÁtH‹IÿÿÜÛÿL‹àA‹†è  I‹$H‹L‹èH‹ğƒæA‹FpH‹øA‹FxH‹ØH‹T$hHĞL‹ÇH‹L$Xÿí&ÜÿJ;L‹ÇH‹¼$    H‹ÏÿÕ&ÜÿH…öt/I‹]şI‹EH‹8I‹¶ğ  H‰\$ L‹L$XL‹„$    H‹×I‹ÌHÿÖëI‹ø  M‹ÍL‹D$XH‹×I‹ÌHÿÓ„À„ƒ  I‹@  öÁtH‹Iÿÿ[ÛÛÿL‹àA‹†   I‹$H‹L‹èH‹ğƒæA‹†€   H‹øA‹†ˆ   H‹ØH‹T$hHĞL‹ÇH‹L$`ÿ&&ÜÿJ;L‹ÇH‹¼$¨   H‹Ïÿ&ÜÿH…öt/I‹]şI‹EH‹8I‹¶  H‰\$ L‹L$`L‹„$¨   H‹×I‹ÌHÿÖëI‹  M‹ÍL‹D$`H‹×I‹ÌHÿÓ„À„¼   I‹`  öÁtH‹Iÿÿ”ÚÛÿL‹àA‹†  I‹$H‹L‹èH‹ğƒæA‹†   H‹øA‹†˜   H‹ØH‹T$hHĞL‹ÇH‹L$pÿ_%ÜÿJ;L‹ÇL‹¼$¸   I‹ÏÿG%ÜÿH…öt*I‹]şI‹EH‹8I‹¶   H‰\$ L‹L$pM‹ÇH‹×I‹ÌHÿÖëI‹(  M‹ÍL‹D$pI‹×I‹ÌHÿÓë2ÀHÄĞ   A_A^A]A\_^[ÃÌSVWAVAWHƒì0I‹ñM‹ğL‹úH‹ùH‰L$ ÿî˜ÛÿH‹L$ H‹	HÊÿèbĞK H‹Ø‹C8L‹ÀHOI‹×ÿœ$Üÿ‹C@€? H‹CHL‹ÀI‹Öÿƒ$Üÿ‹CPL‹À‹CXHH‹Öÿm$Üÿ‹C`L‹À‹ChHH‹”$€   ÿR$Üÿ‹CpL‹À‹CxHH‹”$ˆ   ÿ7$Üÿ‹ƒ€   L‹À‹ƒˆ   HH‹”$   ÿ$Üÿ‹ƒ   L‹À‹ƒ˜   HH‹”$˜   ÿõ#ÜÿHƒÄ0A_A^_^[ÃSWHƒì8H‹úH‹ÙH‰L$ H‹L$ H‹	HÊÿèsÏK L‹ÀA‹€˜   €; HA‹€   L‹ÀH‹ÏÿŸ#ÜÿH‹ÇHƒÄ8_[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌSWHƒì8H‹úH‹ÙH‰L$ H‹L$ H‹	H¶ÊÿèÏK L‹ÀA‹€ˆ   €; HA‹€€   L‹ÀH‹Ïÿ?#ÜÿH‹ÇHƒÄ8_[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌSWHƒì8H‹úH‹ÙH‰L$ H‹L$ H‹	HVÊÿè³ÎK L‹ÀA‹@x€; HA‹@pL‹ÀH‹Ïÿå"ÜÿH‹ÇHƒÄ8_[ÃÌÌÌSWHƒì8H‹úH‹ÙH‰L$ H‹L$ H‹	HÊÿècÎK L‹ÀA‹@h€; HA‹@`L‹ÀH‹Ïÿ•"ÜÿH‹ÇHƒÄ8_[ÃÌÌÌSWHƒì8H‹úH‹ÙH‰L$ H‹L$ H‹	H¶ÊÿèÎK L‹ÀA‹@X€; HA‹@PL‹ÀH‹ÏÿE"ÜÿH‹ÇHƒÄ8_[ÃÌÌÌSWHƒì8H‹úH‹ÙH‰L$ H‹L$ H‹	HfÊÿèÃÍK L‹ÀA‹@@€; HA‹@HL‹ÀH‹Ïÿõ!ÜÿH‹ÇHƒÄ8_[ÃÌÌÌSWHƒì8H‹úH‹ÙH‰L$ H‹L$ H‹	HÊÿèsÍK ‹@8L‹ÀHSH‹Ïÿ°!ÜÿH‹ÇHƒÄ8_[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌHƒì8H‰L$ €9 HƒÁè   HƒÄ8ÃÌÌÌÌÌSHƒì H‹ÙH‹	H…Ét	H‹HÿP0ëH‹pìÛÿÿR ÜÿHHH‹CH‰ÿ)€ÛÿHƒÄ [ÃÌÌHƒì8L‹ÂH‰L$ €9 HƒÁH‹D$ H‹ H‹@8¨tH‹@ÿH‹öÂtH‹Rÿè   HƒÄ8ÃÌÌSVWHƒì H‰T$HI‹ØH‹ùH‹D$HH‹@8¨tH‹@ÿH‹ËH‹PöÂtH‹Rÿÿg ÜÿH…ÀtRH‹sH‹SH‹ÿù”Ûÿ„Àt=H‹¶ëÛÿÿ˜ÜÿH‹ØH‹OH‰HH‹ëÛÿÿ€ÜÿH‰pH‹ĞH‹ËÿÀ”Ûÿ„Àt°ë2ÀHƒÄ _^[ÃÌÌÌÌÌÌH‹ÁI‹ÈH‹ÿ™ÜÿH‹@I‰ÃÌÌÌÌÌÌÌÌÌSWHƒì(H‹ùH‹H‹=ëÛÿÿÜÿH‹WH‰PH‹ĞH‹ËÿKÑÛÿHƒÄ(_[ÃÌÌÌÌÌÌÌÌÌÌÌH‹AÃÌÌÌÌÌÌÌÌÌÌÌH‹ÁI‹Ğÿ,ÜÿL‰HÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌHƒì8H‰L$ €9 HƒÁè   HƒÄ8ÃÌÌÌÌÌSHƒì H‹ÙH‹	H…Ét	H‹HÿP0ëH‹øåÛÿÿ‚ÜÿHHŠCˆÿqÛÿHƒÄ [ÃÌÌÌÌHƒì8L‹ÂH‰L$ €9 HƒÁH‹D$ H‹ H‹@8¨tH‹@ÿH‹öÂtH‹Rÿè   HƒÄ8ÃÌÌSVWHƒì H‰T$HI‹ØH‹ùH‹D$HH‹@8¨tH‹@ÿH‹ËH‹PöÂtH‹Rÿÿ—ÜÿH…ÀtPH‹sH‹SH‹ÿ)“Ûÿ„Àt;H‹>åÛÿÿÈÜÿH‹ØŠOˆHH‹(åÛÿÿ²Üÿ@ˆpH‹ĞH‹Ëÿò’Ûÿ„Àt°ë2ÀHƒÄ _^[ÃÌÌÌÌÌÌÌÌH‹ÁI‹ÈH‹ÿÉÜÿŠ@AˆÃÌÌÌÌÌÌÌÌÌÌSWHƒì(H‹ùH‹H‹ÅäÛÿÿOÜÿŠWˆPH‹ĞH‹Ëÿ}ÏÛÿHƒÄ(_[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌŠAÃÌÌÌÌÌÌÌÌÌÌÌÌHƒì8H‰L$ €9 HƒÁè   HƒÄ8ÃÌÌÌÌÌSHƒì H‹ÙH‹©çÛÿÿãÜÿHHóÿj{ÛÿHƒÄ [ÃÌÌÌHƒì8L‹ÂH‰L$ €9 HƒÁH‹D$ H‹ H‹@8¨tH‹@ÿH‹öÂtH‹Rÿè   HƒÄ8ÃÌÌSVWHƒì@H‰T$hI‹ØH‹ùH‹D$hH‹@8¨tH‹@ÿH‹ËH‹PöÂtH‹Rÿÿ÷ÜÿH…ÀtjH‹CH‰D$ H‹CH‰D$(H‹sH‹íæÛÿÿ'ÜÿH‹Øó@H‹ÕæÛÿÿÜÿD$ ó@H‹ĞH‹ËÿI‘Ûÿ„ÀtH‹ÖH‹Oÿ8‘Ûÿ„Àt°ë2ÀHƒÄ@_^[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌH‹ÑóA I‹ÉH‹Rÿ ÜÿÃÌÌÌÌÌÌÌSHƒì0ft$ H‹Ù1H‹PæÛÿÿŠÜÿópH‹SH‹Èÿ¸ÍÛÿfot$ HƒÄ0[ÃÌÌÌÌHƒì3ÀH‰$H‰$H‹$ó H‹ÂHƒÄÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌA óHƒÁI‹ÑÿsÜÿÃÌÌÌÌÌÌÌÌÌÌHƒì8H‰L$ H‹D$ H‹ H‹@P¨tH‹@ÿH‹ H‹ L‹ I;Ètÿ¸ÛÿHƒÄ8ÃÌÌÌÌÌÌÌÌÌSVWHƒì H‰L$@H‹t$@H‹vP@öÆtH‹vÿH‹VH‹HƒÂğÿ ÜÿH‹FH‹ H‹øH‹XH…Ûu0H‹NöÁtH‹IÿH‹V H‹ÿÒH‹ØLm_úÿH‹H‹Èÿ¹¥ÛÿH‰_H‹N(öÁtH‹IÿH‹Óè¨|úÿHƒÄ _^[ÃÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌHƒy ”ÀÃÌÌÌÌÌÌÌHƒì(A°3Òÿ·ÛÿHƒÄ(ÃÌÌÌÌÌÌÌÌÌÌÌSHƒì H‹ÙèÓ  ‹S è«  HƒÄ [ÃÌÌÌÌSWHƒì8‹A ƒà w‹A ƒàw‹A ƒà?uèM  HƒÄ8_[Ãè ‡  H‹ØH‹nåÛÿÿ¨ÜÿH‹øH‹ÓH‹Èÿ¡xÛÿº  €H‹Ïèô„  H‹ÏÿëÜÿÌÌÌÌÌÌÌÌÌÌÌSHƒì@H‹ÙÆD$0 HD$0H‰D$ A±º   DBıèh  €|$0 uH‹KH…Étÿú©ÛÿHƒÄ@[ÃÌÌÌÌÌÌÌÌÌÌÌSWHƒì8H‹úH‹Ùèï  €; HK0H‹×E3ÀÿÔÜÿH…ÀuGH…ÿt:‹C %   t0‹C ƒà vHK03ÒÿÌÜÿëH‹Ëèª  ‹S è‚  ‹ĞH‹Ëè  HƒÄ8_[Ãèû…  H‹ØH‹iäÛÿÿ£ÜÿH‹øH‹ÓH‹ÈÿœwÛÿº  €H‹Ïèïƒ  H‹ÏÿæÜÿÌÌÌÌÌÌSHƒì@H‹ÙÆD$0 HD$0H‰D$ E3ÉE3ÀAQ èj  Hƒc Hƒc( Hƒc Hƒc0 Hƒc8 Hƒc@ HƒÄ@[ÃÌÌÌÌÌÌUSHƒìXHl$ H‹ÙH‰M Hƒe 3ÀH‰E(èŞ  ‹C ƒàvH‹Ëè>À÷ÿH‹Èÿ-µÛÿ€8 H‹Èÿ1µÛÿ‹C ƒàw3ÒèªÌ÷ÿH‹Èÿ1Üÿ‹C %    H‹K(vH\¹˜ÿÿæÜÿŠ@ë3H
+¤ÿÿ|ÜÿH…Àt!Hƒe ÆE  Hƒe( H‰EHMè¤„  ˆE ŠE He8[]ÃHƒì(H‰MH‹Ñè7Ì÷ÿH‹Èÿ¾ÜÿHÖÿÿÿHƒÄ(ÃÌÌƒâ?ƒú	s'HcÊHN¦¾ÿHcˆHÈÿáëş3Àë¸   ë¸   ë¸   ÃÌÌÌÌÌÌÌÌÌÌÌUSVWATAVAWHƒì0Hl$ H‰MPH‹ùH‰Mèı   ‹Ğè–ÿÿÿD‹øHƒe  L‹w@M…öu‹ĞH‹Ïè  é   L‹eM‹$$M‹d$8AöÄtM‹d$ÿI‹$H‹HƒÂğÿÜÿI‹D$H‹ H‹ØH‹pH…öu'H‹ªçÛÿÿtÜÿH‹ğLRvúÿH‹H‹Èÿ®¡ÛÿH‰sI‹L$öÁtH‹IÿI‹T$H‹ÿÒH‹ØE‹ÇH‹×H‹Èè)öÿL‹ÃH‹ÖI‹ÎH‹HÿP@HeA_A^A\_^[]ÃHƒì(H‰M H‹UPH‹R@è”  HÕÿÿÿHƒÄ(ÃÌÌÌÌÌÌÌÌSHƒì@H‹ÙÆD$0 H‹I(H‹éÛÿÿªÜÿ€8 H‹ÈÿVªÛÿƒÀûƒøs#HcÈHì¤¾ÿHcˆHÈÿáëşº   ëº   ëº   HD$0H‰D$ A±A¸?   H‹Ëè‹   HƒÄ@[ÃÌÌ